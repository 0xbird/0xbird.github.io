<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1.Javascript 基础</title>
      <link href="/2019/08/27/1.javascript-ji-chu/"/>
      <url>/2019/08/27/1.javascript-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 是一种脚本语言，学一种编程语言，首先就要从这种语言的基础语法入手。本节我们就将对 JavaScript 的基础语法进行学习。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>JavaScript 是什么</li><li>变量</li><li>数字与运算符</li><li>数组　</li><li>null &amp; undefined</li><li>字符串</li><li>类型转换</li></ul><h2 id="什么是-JavaScript"><a href="#什么是-JavaScript" class="headerlink" title="什么是 JavaScript"></a>什么是 JavaScript</h2><p>JavaScript，通常缩写为 JS，是一种高级的，解释执行的编程语言。JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。它提供语法来操控文本、数组、日期以及正则表达式等，不支持 I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它已经由 ECMA（欧洲计算机制造商协会）通过 ECMAScript 实现语言的标准化。它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持。</p><p>虽然 JavaScript 与 Java 这门语言不管是在名字上，或是在语法上都有很多相似性，但这两门编程语言从设计之初就有很大的不同，JavaScript 的语言设计主要受到了 Self（一种基于原型的编程语言）和 Scheme（一门函数式编程语言）的影响。在语法结构上它又与C语言有很多相似（例如 if 条件语句、while 循环、switch 语句、do-while 循环等）。</p><p>在客户端，JavaScript 在传统意义上被实现为一种解释语言，但在最近，它已经可以被即时编译（JIT）执行。随着最新的 HTML5 和 CSS3 语言标准的推行它还可用于游戏、桌面和移动应用程序的开发和在服务器端网络环境运行，如 Node.js。</p><h4 id="JavaScript-的组成"><a href="#JavaScript-的组成" class="headerlink" title="JavaScript 的组成"></a>JavaScript 的组成</h4><ul><li>ECMAScript：JavaScript 的语法标准。</li><li>DOM：JavaScript 操作网页上的元素的 API。</li><li>BOM：JavaScript 操作浏览器的部分功能的 API。</li></ul><h4 id="JavaScript-的特点"><a href="#JavaScript-的特点" class="headerlink" title="JavaScript 的特点"></a>JavaScript 的特点</h4><ul><li>可以使用任何文本编辑工具编写，然后使用浏览器就可以执行程序。</li><li>是一种解释型脚本语言：代码不进行预编译，从上往下逐行执行，不需要进行严格的变量声明。</li><li>主要用来向 HTML 页面添加交互行为。</li></ul><h2 id="JavaScript-范例"><a href="#JavaScript-范例" class="headerlink" title="JavaScript 范例"></a>JavaScript 范例</h2><p>新建一个 test.html 文件</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>        <span class="token operator">&lt;</span>script<span class="token operator">></span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码，我们可以看出 JavaScript 代码是放在<script> ……</script> 标签里，而包含 JavaScript 代码的 script 标签，我们可以放在 <body> ……</body>标签里，也可以放在<head><meta name="generator" content="Hexo 3.9.0"> ……<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>标签里。比如上述范例也可以这样写：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>        <span class="token operator">&lt;</span>script<span class="token operator">></span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果没有什么区别，不同的是执行顺序，简单的来说，放在前面的会先执行。此外，和 CSS 引入相类似，JavaScript 也可以通过外部引入。首先我们需要创建一个扩展名为 .js 的文件，然后在 html 页面中引入它，同样的拿上述范例来修改，我们首先创建一个叫 test.js (名字自己取，但是扩展名一定要是 .js,只有这样才能够识别 JavaScript 代码)的文件，然后在里面写上我们的 JavaScript 代码：</p><pre><code>console.log(&quot;hello world&quot;);</code></pre><p>在 html 文件中写上如下代码：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>        <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"test.js"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是 test.js 文件要和你的 html 文件在同一目录下才能用上面的方式引用，否则的话需要使用相对路径还是绝对路径来引入 js 文件，就需要根据实际情况灵活运用了。前两种方式都是直接把 JavaScript 代码放在 HTML 中，在页面加载的同时，那些 JavaScript 的代码就被解析了。而把 JavaScript 代码放在外部文件中，只有在事件被触发，需要该段 JavaScript 代码时，才调用执行。这样做有个好处，当页面比较复杂的时候，把大量的 JavaScript 代码放到外部文件，只有在需要的时候才执行，那么会明显地加快页面加载速度，而且实现结构化分离，也便于我们维护自己的代码，所以建议大家养成外部引入的方式来写我们的 JavaScript 代码。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="变量是什么"><a href="#变量是什么" class="headerlink" title="变量是什么"></a>变量是什么</h4><p>在计算机中，数据都存在内存中。而一个变量，就是一个用于存放数值的容器，每个变量存放的数值是可变的，每个变量都有其独有的名字，每个变量都占有一段内存。</p><p>注：变量不是数值本身，变量仅仅是一个用于储存数值的容器。</p><h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p>通过 var 关键字来声明变量，比如：</p><pre><code>var name = &quot;实验楼&quot;;</code></pre><p>上述代码声明了一个名为 name 的变量，并赋值为“实验楼”，注意此处的等于符号（=）为赋值符号，不是我们传统意义上理解的等号。</p><p>变量的命名规则如下：</p><ul><li>变量名必须以字符或下划线“_”开头，不能以数字开头</li><li>变量可以包含数字、从 A 至 Z 的大小字母</li><li>不能使用 JavaScript 中的关键字做变量名</li><li>变量名不能有空格</li><li>严格区分大小写，比如：name 和 Name 就是两个完全不同的变量。</li></ul><p>另外在 JavaScript 中，变量也可以不作声明，而在使用时再根据数据的类型来确其变量的类型，如：</p><pre><code>x = 50 ;     // 变量 x 为整数</code></pre><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul><li>Number:你可以在变量中存储数字，不论这些数字是像 10（整数）这样，或者像 3.1415926（浮点数）。</li></ul><pre><code>var x1 = 10;var x2 = 3.1415926;</code></pre><ul><li>String:存储字符（比如 “shiyanlou”）的变量，字符串可以是引号中的任意文本，你可以使用单引号或双引号，也可以在字符串中使用引号，只要不匹配包围字符串的引号即可：</li></ul><pre><code>var carname=&quot;shiyanlou&quot;;var carname=&#39;shiyanlou&#39;;var answer=&quot;I Love &#39;shiyanlou&#39;&quot;;var answer=&#39;I Love &quot;shiyanlou&quot;&#39;;</code></pre><ul><li>Boolean:布尔类型的值有两种：true 和 false。通常被用于在适当的代码之后，测试条件是否成立，后续会讲到。</li><li>Array：数组是一个单个对象，其中包含很多值，方括号括起来，并用逗号分隔。后续我们将会对数值进行详细的讲解，此处看两个简单的数值例子：</li></ul><pre><code>var myNameArray = [&#39;Tom&#39;, &#39;Bob&#39;, &#39;Jim&#39;];var myNumberArray = [10,15,20];</code></pre><ul><li>Object:对象类型。同样的我们会在后续的课程中详细讲解什么是对象，此处先看一个简单的例子：</li></ul><pre><code>var student = { name : &#39;Tom&#39;, age : 18 };</code></pre><h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h4><p>JavaScript 是一种“动态类型语言”，这意味着不同于其他一些语言(如 C、Java)，你不需要指定变量将包含什么数据类型（例如 number 或 string）,通通用 var 关键字声明就是了。比如如果你声明一个变量并给它一个带引号的值，浏览器就会知道它是一个字符串：</p><pre><code>var myString = &#39;Hello&#39;;</code></pre><p>值得注意的是就是引号中是一个数字，它依然是 string 类型的。我们可以在控制台中通过 typeof 函数，来查看我们声明的变量是什么类型的。</p><p><img src="/2019/08/27/1/1565971344000.png" alt></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行注释：用来描述下面一个或多行代码的作用。单行注释快捷键：Ctrl + /</p><pre><code>//这是一个变量var name = &quot;zhangsan&quot;;</code></pre><p>多行注释：用来注释多条代码。多行注释快捷键：Ctrl + Shift + /</p><pre><code>/*var name = &quot;zhangsan&quot;;var age = 18;console.log(name, age);*/</code></pre><h2 id="数字与运算符"><a href="#数字与运算符" class="headerlink" title="数字与运算符"></a>数字与运算符</h2><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><ul><li>整数。例如：1,2,100，-10。</li><li>浮点数:就是小数。例如：0.2，3.1415926。</li><li>双精度：是一种特定类型的浮点数，它们具有比标准浮点数更高的精度。</li></ul><p>注：我们这里作为了解就可以了。因为和其他语言不同的是，在 JavaScript 中，不管什么数字类型的通通用 var 声明就可以了，而且 JavaScript 中只有一个数据类型:Number。</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p><img src="/2019/08/27/1/1566899363039.png" alt></p><p>加减乘除的运算和我们平时所用的差不多，大家可以自行在控制台中尝试。这里需要提醒大家的是累加运算和累减运算的用法:</p><p><img src="/2019/08/27/1/1566899404800.png" alt></p><p>从上述的图片中可以看出我们不能将这些直接应用于一个数字，不是对值进行操作，而是为变量赋值一个新的更新值。num++ 其实是 num = num + 1 的省略写法。从图片上来看可能不好理解 num++ 和 ++num 的区别。我们来写一个例子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">var</span> result1 <span class="token operator">=</span> num1<span class="token operator">++</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">var</span> result2 <span class="token operator">=</span> <span class="token operator">++</span>num2<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后控制台打印的数字为：3 4 5 5。这里我们也可以看出 num++ 和 ++num 的区别，前者是先赋值再自增，后者是先自增再赋值。同样的 num– 和 –num 也是一样的效果，大家可以自行尝试一下。</p><h4 id="操作运算符"><a href="#操作运算符" class="headerlink" title="操作运算符"></a>操作运算符</h4><p><img src="/2019/08/27/1/1566899435300.png" alt></p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p><img src="/2019/08/27/1/1566901057367.png" alt></p><p>在控制台中输入这些示例，如果成立的话会返回 true 如果不成立的话则返回 false。</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><img src="/2019/08/27/1/1566900052814.png" alt></p><h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><p><img src="/2019/08/27/1/1566901074842.png" alt></p><h2 id="数组（概述，方法）"><a href="#数组（概述，方法）" class="headerlink" title="数组（概述，方法）"></a>数组（概述，方法）</h2><p>数组是多数编程语言都具有的数据类型，JavaScript 也不例外，接下来让我们一起来学习 JavaScript 数组的定义和相关操作。</p><h3 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h3><p>通过我们前面所学的我们可以知道如果我们要保存一个数据，我们可以用 var 关键字去定义一个变量，但是如果数据很多呢？难道我需要一个个去定义？比如一个班上很多人，我们 var name1 = “张三”;var name2 = “李四”;…一直这样定义下去？显然这是不科学的，而这也由此引出了我们的数组。首先我们来看看维基百科对于数组的定义：</p><blockquote><p>在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p></blockquote><p>最简单的数据结构类型是一维数组。例如，索引为 0 到 9 的 32 位整数数组，可作为在存储器地址2000，2004，2008，…2036中，存储10个变量，因此索引为 i 的元素即在存储器中的 2000+4×i 地址。数组第一个元素的存储器地址称为第一地址或基础地址。</p><h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> myarray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建数组同时赋值</span><span class="token comment" spellcheck="true">//or</span><span class="token keyword">var</span> myarray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//直接输入一个数组（称 “字面量数组”）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：我们可以用上述两种方法创建数组，myarray 指的是定义的数组名，可以自己取，数组储存的的数据可以是任何类型（数字，字符，布尔值等）。每一个值都有一个索引值，从 0 开始。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span><span class="token string">"green"</span><span class="token punctuation">,</span><span class="token string">"blue"</span><span class="token punctuation">,</span><span class="token string">"yellow"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>color<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "red"</span>color<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "green"</span>color<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "blue"</span>color<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "yellow"</span>color<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>多维数组就是数组中还包含数组，我们可以一层一层的来看。比如：</p><pre><code>var student = [[&quot;张三&quot;,&quot;男&quot;,&quot;18&quot;],[&quot;李四&quot;,&quot;女&quot;,&quot;20&quot;]];student[0][2]; // returns &quot;18&quot;</code></pre><h3 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h3><h4 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h4><p>修改数组中的元素内容也很简单，直接为它提供新值就可以了。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span><span class="token string">"green"</span><span class="token punctuation">,</span><span class="token string">"blue"</span><span class="token punctuation">,</span><span class="token string">"yellow"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>color<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">;</span>color<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns  ["black", "green", "blue", "yellow"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>同样的我们使用 length 来获取数组的长度。比如：</p><pre><code>var color = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;];color.length; // returns 4</code></pre><h4 id="数组和字符串之间的转换"><a href="#数组和字符串之间的转换" class="headerlink" title="数组和字符串之间的转换"></a>数组和字符串之间的转换</h4><p>通过 split() 方法，将字符串转换为数组。比如：</p><pre><code>&quot;1:2:3:4&quot;.split(&quot;:&quot;)    // returns [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]&quot;|a|b|c&quot;.split(&quot;|&quot;)    // returns [&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><p>相反的我们通过 join() 方法将数组转换为字符串。比如：</p><pre><code>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;].join(&quot;:&quot;); // returns &quot;1:2:3:4&quot;[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;].join(&quot;|&quot;); // returns &quot;|a|b|c&quot;</code></pre><p>注：我们同样可以使用 toString() 方法将数组转换为字符串，但是 join() 方法可以指定不同的分隔符，而 toString() 方法只能是逗号。</p><h4 id="添加和删除数组项"><a href="#添加和删除数组项" class="headerlink" title="添加和删除数组项"></a>添加和删除数组项</h4><p>在数组尾部添加一个或多个元素，使用 push() 方法。比如：</p><pre><code>var arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;];arr.push(&quot;5&quot;,&quot;6&quot;);arr; // returns [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]</code></pre><p>使用 pop() 方法将删除数组的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，然后返回 undefined 值。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//returns 4</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns ["1", "2", "3"]</span><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//returns undefined</span>arr1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//returns []</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>unshift() 和 shift() 从功能上与 push() 和 pop() 完全相同，只是它们分别作用于数组的开始，而不是结尾。大家可以直接在控制台自行尝试一番。</p><h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><p>null 和 undefined 都表示无,但是也有一些区别。现在控制台上执行以下语句：</p><p><img src="/2019/08/27/1/1566901102698.png" alt></p><p>这里需要说明的是：== 是相等操作符,比较值是否相等，如果相等输出为 true，否则为 false。=== 是全等操作符,比较值和类型是否都相等，如果都相等输出为 true，否则为 false。通过我们在控制台中的实践可以发现，null 和 undefined 的值不等于 0，它们的值相等，但是类型不相等。undefined 表示所有没有赋值变量的默认值，而 null 则表示一个变量不再指向任何对象地址。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在前面的变量章节中，我们已经简单讲过字符串的基础知识，这里我们再拓展一下。我们前面讲过我们可以使用单引号或双引号，也可以在字符串中使用引号，只要不匹配包围字符串的引号即可。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> carname<span class="token operator">=</span> <span class="token string">"shiyanlou"</span><span class="token punctuation">;</span><span class="token keyword">var</span> carname<span class="token operator">=</span> <span class="token string">'shiyanlou'</span><span class="token punctuation">;</span><span class="token keyword">var</span> answer<span class="token operator">=</span> <span class="token string">"I Love 'shiyanlou'"</span><span class="token punctuation">;</span><span class="token keyword">var</span> answer<span class="token operator">=</span> <span class="token string">'I Love "shiyanlou"'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面的代码将会出现错误，因为它会混淆浏览器和字符串的结束位置:</p><pre><code>var x1 = &#39;I&#39;ve got no right to take my place...&#39;;</code></pre><p>聪明的你可能会觉得这样不行，我们就换种方法嘛，比如：</p><pre><code>var x1 = &#39;I have got no right to take my place...&#39;;</code></pre><p>或者：</p><pre><code>var x1 = &quot;I&#39;ve got no right to take my place...&quot;;</code></pre><p>没错这样做都是可行的方法，但是其实我们还有另外一种方法，使用转义符号。转义字符意味着我们对它们做一些事情，以确保它们在文本中被认可，而不是代码的一部分。在 JavaScript 中，我们通过在字符之前放一个反斜杠来实现这一点。试试这个:</p><pre><code>var x1 = &#39;I\&#39;ve got no right to take my place...&#39;;</code></pre><p>常用的转义符：</p><p><img src="/2019/08/27/1/1566901117702.png" alt></p><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p>我们通过 “+” 连接字符串，比如在控制台中输入下面的代码：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> one <span class="token operator">=</span> <span class="token string">"Hello,jack."</span><span class="token punctuation">;</span><span class="token keyword">var</span> two <span class="token operator">=</span> <span class="token string">"I'm rose"</span><span class="token punctuation">;</span>result <span class="token operator">=</span> one <span class="token operator">+</span> two<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后控制台显示结果为：”Hello,jack.I’m rose”。</p><p>如果我们在控制台输入的是 “jack”+18 思考一下会报错吗？要不再自己动手实践看看结果？结果是：浏览器很聪明的把数字转换成了字符串，最后结果为”jack18”。另外输入 “20”+”19”，最后的结果也是字符串”2019”。</p><h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><p>我们可以通过 toString 方法把数字转换成字符串。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> myNum <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">var</span> myString <span class="token operator">=</span> myNum<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> myString<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以通过 Number 对象把传递给它的字符串类型的数字转换为数字。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> myString <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span><span class="token keyword">var</span> myNum <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>myString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> myNum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注：如果传递的不是纯数字的字符串，则返回的不是数字，而是 NaN（not a number）。</p><h4 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h4><p>通过 length 属性获取字符串的长度,结果返回一个数字。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> myString <span class="token operator">=</span> <span class="token string">"hello world "</span><span class="token punctuation">;</span>myString<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述代码在控制台中运行的结果为：12（除了字母还有两个空格）。</p><p>如果你要查找这个字符串的第一个字符，你可以这么做：</p><pre><code>myString[0];</code></pre><p>同样的你也可以查找到其他的字符，比如第五个字符，就是 myString[4]，这是因为电脑是从 0 开始，而不是 1，因此我们都要执行减一操作。</p><h4 id="在字符串中查找子字符串并提取它"><a href="#在字符串中查找子字符串并提取它" class="headerlink" title="在字符串中查找子字符串并提取它"></a>在字符串中查找子字符串并提取它</h4><ol><li>有时候我们需要判断一个较长的字符串里面是否存在一个我们指定的较小的字符串，就比如我们要查找一段话里面是否包含一个词或者一个字，这个时候我们可以使用 indexof() 方法来完成，更详细的语法为：</li></ol><pre><code>str.indexOf(searchValue, fromIndex);</code></pre><p>str 指的是我们需要查的较长的字符串，searchValue 表示我们指定的较小的字符串，fromIndex 表示调用该方法的字符串中开始查找的位置，是一个可选的任意整数值，也可以不写，默认是 0 表示从头开始查，fromIndex &lt; 0 和 fromIndex = 0 是一样的效果，表示从头开始查找整个字符串。如果 fromIndex &gt;= str.length,则该方法的返回值为 -1。这里有个特殊的情况：就是如果被查找的字符串（searchValue）是一个空字符串，那么当 fromIndex &lt;= 0 时返回 0，0 &lt; fromIndex &lt;= str.length 时返回 fromIndex，fromIndex &gt; str.length 时返回 str.length。这样说你可能不太明白，我们来实践一下看看实际效果：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// returns  0</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Ble"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// returns -1</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Sky"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns  5</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Sky"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns  5</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Sky"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns  5</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Sky"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns -1</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// returns  0</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// returns 5</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// returns 8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：返回值指的是指定值的第一次出现的索引，如果没有找到 -1。indexOf 方法区分大小写，比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns -1</span><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"Blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>当你知道字符串中的子字符串开始的位置，以及想要结束的字符时，slice()方法可以用来提取 它。比如：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "Blu"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：slice(strat，end)，第一个参数 start 是开始提取的字符位置，第二个参数 end 是提取的最后一个字符的后一个位置。所以提取从第一个位置开始，直到但不包括最后一个位置。另外第二个参数也可以不写，不写代表某个字符之后提取字符串中的所有剩余字符。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token string">"Blue Sky"</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "ue Sky"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h4><p>字符串方法 toLowerCase() 和 toUpperCase() 字符串并将所有字符分别转换为小写或大写。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">"I like study"</span><span class="token punctuation">;</span>string<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "i like study"</span>string<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "I LIKE STUDY"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="替换字符串的某部分"><a href="#替换字符串的某部分" class="headerlink" title="替换字符串的某部分"></a>替换字符串的某部分</h4><p>可以使用 replace() 方法将字符串中的一个子字符串替换为另一个子字符串。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">"I like study"</span><span class="token punctuation">;</span>string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"study"</span><span class="token punctuation">,</span><span class="token string">"sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "I like sleep"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：字符串的操作方法其实还有很多，我们将在后续的课程中再为大家作深入讲解。</p><h2 id="详解类型转换"><a href="#详解类型转换" class="headerlink" title="详解类型转换"></a>详解类型转换</h2><h3 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h3><ol><li>几乎每个值都有 toString() 方法。比如在控制台输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">var</span> numString <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numString<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// returns "8"</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">var</span> resultString <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>resultString<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// returns "true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数值类型的 toString() ,可以携带一个参数,输出对应进制的值。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//"16" 默认是10进制</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"16"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"10000"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"20"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"10"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>String() 函数。比如在控制台中输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span>num2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "8"</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">var</span> result1 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>result1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：因为有的值没有 toString() 方法，所以需要用 String(),比如 null 和 undefined。如下所示：</p><p><img src="/2019/08/27/1/1566901142698.png" alt></p><ol><li>使用拼接字符串。比如在控制台中输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> num1 <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>num2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "16"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="转换成数值类型"><a href="#转换成数值类型" class="headerlink" title="转换成数值类型"></a>转换成数值类型</h3><ol><li>Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回 NaN（not a number）。比如在控制台中依次输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> num1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true 返回 1，false 返回 0</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span>num2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回 NaN</span><span class="token keyword">var</span> num3 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回 0</span><span class="token keyword">var</span> num4 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"syl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num4<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回 NaN</span><span class="token keyword">var</span> num5 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num5<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果是空字符串返回 0</span><span class="token keyword">var</span> num6 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num6<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回123，如果是数字型的字符，返回数字</span><span class="token keyword">var</span> num7 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"123abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num7<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回 NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>parseInt() 把字符串转换成整数。比如在控制台中依次输入以下代码：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"12.3abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  num1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回 12，如果第一个字符是数字会解析知道遇到非数字结束,只取整，不是约等于</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"abc123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  num2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回 NaN，如果第一个字符不是数字或者符号就返回 NaN</span><span class="token keyword">var</span> num3 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> num3<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 空字符串返回 NaN，但是 Number("")返回 0</span><span class="token keyword">var</span> num4 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"520"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num4<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//返回 520</span><span class="token keyword">var</span> num5 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0xA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> num5<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外值得注意的是，parseInt()可以传递两个参数，第一个参数是要转换的字符串，第二个参数是要转换的进制。大家可以自行尝试一下。</p><ol><li>parseFloat()把字符串转换成浮点数。写法和parseInt()相似，主要有以下几个不同点：</li></ol><ul><li>parseFloat不支持第二个参数，只能解析 10 进制数</li><li>如果解析的内容里只有整数，解析成整数</li></ul><p>例子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10.000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10.01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10.01</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">" 10 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"10 hours"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 10</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"aaa 10 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>执行减 0 操作。比如：</li></ol><pre><code>var n=&quot;10&quot;;var m=n-0;m; // returns 10</code></pre><p>值得注意的是，如果该字符串不是纯粹的数字字符串，那么它执行减 0 操作后，虽然变成了一个数字类型，但是返回值为 NaN。比如：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token keyword">var</span> m <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">;</span>m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns NaN</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns "number"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="转换成布尔类型"><a href="#转换成布尔类型" class="headerlink" title="转换成布尔类型"></a>转换成布尔类型</h3><ol><li>使用 Boolean() 函数。比如：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// returns true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>流程控制语句会把后面的值隐式转换为布尔类型。比如：</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> message<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//会自动把message转换成false,最后打印结果为:我很好</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"你好啊"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我很好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要就 JavaScript 的基础语法进行了学习，主要包括以下内容：</p><ul><li>JavaScript 是什么</li><li>变量</li><li>数字与运算符</li><li>数组</li><li>null &amp; undefined</li><li>字符串</li><li>类型转换</li></ul><p>本节内容是对 JavaScript 基础知识的初步认识。请务必手动完成文档中的所有例子，并实际运行查看效果。加深对基础知识的理解，并达到灵活运用的水平。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AFL对Linux内核Fuzzing的总结</title>
      <link href="/2018/01/22/article-title/"/>
      <url>/2018/01/22/article-title/</url>
      
        <content type="html"><![CDATA[<p>模糊测试是一种很好的漏洞挖掘技术，Fuzzer将半随机输入喂到到测试程序，目的是找到触发错误的输入。模糊测试在查找C或C ++程序中的内存破坏漏洞时特别有用。</p><p>通常情况下，建议选择一个众所周知但很少探索的库，这个库在解析时很重要。历史上，像libjpeg，libpng和libyaml这样的东西都是完美的目标。如今找到一个好目标更难 - 一切似乎都已经被模糊化了。这是好事！我猜软件越来越好了！我没有选择用户空间目标，而是选择了Linux内核netlink机器。</p><p>Netlink是一个Linux内核工具，它用于配置网络接口，IP地址，路由表等。这是一个很好的fuzzing 目标：它是内核的一个小模块，并且生成畸形有效消息相对比较容易。最重要的是，我们可以在此过程中学到很多关于Linux内核的知识。</p><p>在这篇文章中，我将使用AFL模糊器，将netlink shim程序与自定义Linux内核相对应，所有这些都在KVM虚拟机中运行。</p><h3 id="以前的技术支持"><a href="#以前的技术支持" class="headerlink" title="以前的技术支持"></a>以前的技术支持</h3><p>我们将要使用的技术被称为“覆盖引导模糊测试”。有很多以前的文献：</p><ul><li>Dan Guido <a href="https://blog.trailofbits.com/2017/02/16/the-smart-fuzzer-revolution/" target="_blank" rel="noopener">的智能模糊革命</a>，以及<a href="https://lwn.net/Articles/677764/" target="_blank" rel="noopener">LWN</a>关于它的<a href="https://lwn.net/Articles/677764/" target="_blank" rel="noopener">文章</a></li><li>Mateusz“j00ru”Jurczyk的<a href="https://j00ru.vexillium.org/talks/blackhat-eu-effective-file-format-fuzzing-thoughts-techniques-and-results/" target="_blank" rel="noopener">有效文件格式模糊</a>测试</li><li><a href="http://honggfuzz.com/" target="_blank" rel="noopener">honggfuzz</a>是一个现代化的，功能丰富的覆盖面引导的fuzzer</li><li><a href="https://google.github.io/clusterfuzz/" target="_blank" rel="noopener">ClusterFuzz</a></li><li><a href="https://github.com/google/fuzzer-test-suite" target="_blank" rel="noopener">Fuzzer测试套件</a></li></ul><p>很多人过去都在Fuzzing Linux内核：</p><ul><li>由Dmitry Vyukov <a href="https://github.com/google/syzkaller/blob/master/docs/syzbot.md" target="_blank" rel="noopener">创建的syzkaller（又名syzbot）</a>是一个非常强大的CI风格的持续运行的内核模糊器，它已经发现了数百个漏洞。</li><li><a href="https://github.com/kernelslacker/trinity" target="_blank" rel="noopener">三位一体的模糊器</a></li></ul><p>我们将使用<a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">AFL</a>，可能是大家最喜欢的模糊器。AFL由<a href="http://lcamtuf.coredump.cx/" target="_blank" rel="noopener">MichałZalewski</a>撰写。它以其易用性，速度和非常好的变异逻辑而闻名，这是开始模糊测试之旅的完美选择！</p><p>如果您想了解有关AFL的更多信息，请参阅几个文件：</p><ul><li><a href="http://lcamtuf.coredump.cx/afl/historical_notes.txt" target="_blank" rel="noopener">历史笔记</a></li><li><a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">技术白皮书</a></li><li><a href="http://lcamtuf.coredump.cx/afl/README.txt" target="_blank" rel="noopener">自述</a></li></ul><h3 id="覆盖引导的模糊测试"><a href="#覆盖引导的模糊测试" class="headerlink" title="覆盖引导的模糊测试"></a>覆盖引导的模糊测试</h3><p>覆盖引导的模糊测试基于反馈回路的原理：</p><ul><li>模糊测试选择最有希望的测试用例</li><li>模糊测试将测试变为大量新的测试用例</li><li>目标代码运行变异的测试用例，并报告代码覆盖率</li><li>模糊器根据报告的覆盖范围计算得分，并使用它来确定有效的变异测试的优先级并删除冗余的测试</li></ul><p>例如，假设输入测试是“hello”。Fuzzer可能会将其变为多种测试，例如：“hEllo”（位翻转），“hXello”（字节插入），“hllo”（字节删除）。如果这些测试中的任何一个将产生有趣的代码覆盖，那么它将被优先化并用作下一次测试的基础。</p><p>有关如何完成突变以及如何有效地比较数千个程序运行的代码覆盖率报告的细节是模糊测试的秘诀，阅读<a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">AFL的技术白皮书</a>，可以了解更多细节。</p><p>通常，在使用AFL时，我们需要检测目标代码，以便以AFL兼容的方式报告覆盖范围。但我们想要Fuzzing 内核！我们不能只用“afl-gcc”重新编译它！。我们将准备一个二进制文件，让AFL认为它是用它的工具编译的。这个二进制文件将报告从内核中提取的代码覆盖率。</p><h3 id="内核代码覆盖率"><a href="#内核代码覆盖率" class="headerlink" title="内核代码覆盖率"></a>内核代码覆盖率</h3><p>内核至少有两个内置的覆盖机制–GCOV和KCOV：</p><ul><li><a href="https://www.kernel.org/doc/html/v4.15/dev-tools/gcov.html" target="_blank" rel="noopener">将gcov与Linux内核一起使用</a></li><li><a href="https://www.kernel.org/doc/html/latest/dev-tools/kcov.html" target="_blank" rel="noopener">KCOV：模糊测试的代码覆盖率</a></li></ul><p>KCOV的设计考虑了模糊测试，因此我们将使用它。</p><p>使用KCOV非常简单。我们必须使用正确的设置编译Linux内核。首先，启用KCOV内核配置选项：</p><pre class="line-numbers language-sh"><code class="language-sh">cd linux./scripts/config \    -e KCOV \    -d KCOV_INSTRUMENT_ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>KCOV能够记录整个内核的代码覆盖率。可以使用KCOV_INSTRUMENT_ALL选项进行设置。有个缺点是，它会减慢我们不想分析的内核部分，并且会在Fuzzing 中引入噪声（降低“稳定性”）。对于初学者，让我们禁用KCOV_INSTRUMENT_ALL并有选择地在实际想要分析的代码上启用KCOV。</p><p>我们专注于Fuzzing netlink，所以在整个“net”目录树上启用KCOV：</p><pre class="line-numbers language-sh"><code class="language-sh">find net -name Makefile | xargs -L1 -I {} bash -c 'echo "KCOV_INSTRUMENT := y" >> {}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一个理想环境中，我们只能为真正感兴趣的几个文件启用KCOV。但是netlink处理遍及网络堆栈代码，现在没有时间进行微调。</p><p>有了KCOV，将增加报告内存损坏错误的可能性。最重要的是<a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html" target="_blank" rel="noopener">KASAN</a>，使用该集合，可以编译我们的KCOV和KASAN启用的内核。</p><p>我们将以kvm运行内核，所以需要切换一下：</p><pre class="line-numbers language-sh"><code class="language-sh">./scripts/config \    -e VIRTIO -e VIRTIO_PCI -e NET_9P -e NET_9P_VIRTIO -e 9P_FS \    -e VIRTIO_NET -e VIRTIO_CONSOLE  -e DEVTMPFS ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="如何使用KCOV"><a href="#如何使用KCOV" class="headerlink" title="如何使用KCOV"></a>如何使用KCOV</h2><p>KCOV非常易于使用。首先，请注意代码覆盖率记录在每个进程的数据结构中。这意味着您必须在用户空间进程中启用和禁用KCOV，并且无法记录非任务事项的覆盖范围，例如中断处理。这对我们的需求来说完全没问题。</p><p>KCOV将数据报告给环形缓冲区。设置非常简单，<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/kcov.c" target="_blank" rel="noopener">请参阅我们的代码</a>。然后你可以使用一个简单的ioctl启用和禁用它：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">ioctl</span><span class="token punctuation">(</span>kcov_fd<span class="token punctuation">,</span> KCOV_ENABLE<span class="token punctuation">,</span> KCOV_TRACE_PC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* profiled code */</span><span class="token function">ioctl</span><span class="token punctuation">(</span>kcov_fd<span class="token punctuation">,</span> KCOV_DISABLE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在此序列之后，环形缓冲区包含启用KCOV的内核代码的所有基本块的％rip值列表。要读取缓冲区，请运行：</p><pre class="line-numbers language-c"><code class="language-c">n <span class="token operator">=</span> <span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kcov_ring<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%lx\n"</span><span class="token punctuation">,</span> kcov_ring<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用像<code>addr2line</code>这样的工具可以将％rip解析为特定的代码行。我们不需要它 - 原始的％rip值对我们来说已经足够了。</p><h2 id="将KCOV喂入AFL"><a href="#将KCOV喂入AFL" class="headerlink" title="将KCOV喂入AFL"></a>将KCOV喂入AFL</h2><p>我们旅程的下一步是学习如何欺骗AFL。请记住，AFL需要一个特制的可执行文件，但我们想要提供内核代码覆盖率。首先，我们需要了解AFL的工作原理。</p><p>AFL设置一个64K 8位数字的数组。该存储器区域称为“shared_mem”或“trace_bits”，并与跟踪的程序共享。数组中的每个字节都可以被认为是检测代码中特定（branch_src，branch_dst）对的命中计数器。</p><p>重要的是要注意AFL更喜欢随机分支标签，而不是重用％rip值来识别基本块。这是为了增加熵 - 我们希望数组中的命中计数器均匀分布。AFL使用的算法是：</p><pre class="line-numbers language-c"><code class="language-c">cur_location <span class="token operator">=</span> <span class="token operator">&lt;</span>COMPILE_TIME_RANDOM<span class="token operator">></span><span class="token punctuation">;</span>shared_mem<span class="token punctuation">[</span>cur_location <span class="token operator">^</span> prev_location<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> prev_location <span class="token operator">=</span> cur_location <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在我们使用KCOV的情况下，我们没有每个分支的编译时随机值。相反，我们将使用哈希函数从KCOV记录的％rip生成统一的16位数。这是如何将KCOV报告提供给AFL“shared_mem”数组：</p><pre class="line-numbers language-c"><code class="language-c">n <span class="token operator">=</span> <span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kcov_ring<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span><span class="token punctuation">;</span>uint16_t prev_location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        uint16_t cur_location <span class="token operator">=</span> <span class="token function">hash_function</span><span class="token punctuation">(</span>kcov_ring<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shared_mem<span class="token punctuation">[</span>cur_location <span class="token operator">^</span> prev_location<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        prev_location <span class="token operator">=</span> cur_location <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从AFL读取测试数据"><a href="#从AFL读取测试数据" class="headerlink" title="从AFL读取测试数据"></a>从AFL读取测试数据</h2><p>最后，我们需要实际编写核心netlink接口的测试代码！首先，我们需要从AFL读取输入数据。默认情况下，AFL将测试用例发送到stdin：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* read AFL test data */</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> buf_len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Fuzzing-netlink"><a href="#Fuzzing-netlink" class="headerlink" title="Fuzzing netlink"></a>Fuzzing netlink</h2><p>然后我们需要将此缓冲区发送到netlink套接字。但我们对netlink的工作原理一无所知！好吧，让我们使用前5个字节的输入作为netlink协议和组ID字段。这将允许AFL找出并猜测这些字段的正确值。代码测试netlink（简化）：</p><pre class="line-numbers language-c"><code class="language-c">netlink_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_NETLINK<span class="token punctuation">,</span> SOCK_RAW <span class="token operator">|</span> SOCK_NONBLOCK<span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> sockaddr_nl sa <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span>nl_family <span class="token operator">=</span> AF_NETLINK<span class="token punctuation">,</span>        <span class="token punctuation">.</span>nl_groups <span class="token operator">=</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span><span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">bind</span><span class="token punctuation">(</span>netlink_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> iovec iov <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf_len <span class="token operator">-</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> sockaddr_nl sax <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span>nl_family <span class="token operator">=</span> AF_NETLINK<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> msghdr msg <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">&amp;</span>sax<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sax<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>iov<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token function">sendmsg</span><span class="token punctuation">(</span>netlink_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* sendmsg succeeded! great I guess... */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本上就是这样！为了速度，我们将它包装在一个模仿<a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html" target="_blank" rel="noopener">AFL“fork服务器”逻辑</a>的短循环中。我将跳过此处的解释，<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/forksrv.c" target="_blank" rel="noopener">请参阅我们的代码了解详细信息</a>。我们的AFL-to-KCOV垫片的结果代码如下所示：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">forksrv_welcome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">forksrv_cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    test_data <span class="token operator">=</span> <span class="token function">afl_read_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kcov_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* netlink magic */</span>    <span class="token function">kcov_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* fill in shared_map with tuples recorded by kcov */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_crash_in_dmesg<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token function">forksrv_status</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token function">forksrv_status</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/fuzznetlink.c" target="_blank" rel="noopener">查看完整的源代码</a>。</p><h2 id="如何运行自定义内核"><a href="#如何运行自定义内核" class="headerlink" title="如何运行自定义内核"></a>如何运行自定义内核</h2><p>我们遗漏了一个重要的部分 - 如何实际运行我们构建的自定义内核。有三种选择：</p><p><strong>“native”</strong>：您可以在服务器上完全启动构建的内核并在本机模糊它。这是最快的技术，但很有问题。如果模糊测试成功找到错误，您将崩溃机器，可能会丢失测试数据。应该避免切割我们坐的树枝。</p><p><strong>“uml”</strong>：我们可以将内核配置为以<a href="http://user-mode-linux.sourceforge.net/" target="_blank" rel="noopener">用户模式Linux运行</a>。运行UML内核不需要任何权限。内核只运行用户空间进程。UML非常酷，但遗憾的是，它不支持KASAN，因此减少了查找内存损坏错误的可能性。最后，UML是一个非常神奇的特殊环境 - 在UML中发现的错误可能与真实环境无关。有趣的是，<a href="https://source.android.com/devices/architecture/kernel/network_tests" target="_blank" rel="noopener">Android network_tests框架</a>使用UML 。</p><p><strong>“kvm”</strong>：我们可以使用kvm在虚拟化环境中运行我们的自定义内核。这就是我们要做的。</p><p>在KVM环境中运行自定义内核的最简单方法之一是使用<a href="https://github.com/amluto/virtme" target="_blank" rel="noopener">“virtme”脚本</a>。有了它们，我们可以避免创建专用的磁盘映像或分区，只需共享主机文件系统。这就是我们运行代码的方式：</p><pre class="line-numbers language-sh"><code class="language-sh">virtme-run \    --kimg bzImage \    --rw --pwd --memory 512M \    --script-sh "<what to run inside kvm>" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但坚持下去。我们忘记了为我们的模糊器准备输入语料库数据！</p><h2 id="构建输入语料库"><a href="#构建输入语料库" class="headerlink" title="构建输入语料库"></a>构建输入语料库</h2><p>每个模糊器都需要精心设计的测试用例作为输入，以引导第一个突变。测试用例应该简短，并尽可能覆盖大部分代码。可悲的是 - 我对netlink一无所知。我们怎么不准备输入语料库…</p><p>相反，我们可以要求AFL“弄清楚”哪些输入有意义。这就是<a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html" target="_blank" rel="noopener">Michał在2014年用JPEG</a>制作的，并且对他<a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html" target="_blank" rel="noopener">有用</a>。考虑到这一点，这是我们的输入语料库：</p><pre class="line-numbers language-sh"><code class="language-sh">mkdir inpecho "hello world" > inp/01.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有关如何编译和运行整个事情的说明都在我们的github上的<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing" target="_blank" rel="noopener">README.md中</a>。归结为：</p><pre class="line-numbers language-sh"><code class="language-sh">virtme-run \    --kimg bzImage \    --rw --pwd --memory 512M \    --script-sh "./afl-fuzz -i inp -o out -- fuzznetlink" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过此运行，您将看到熟悉的AFL状态屏幕：</p><p><img src="/.top//1566885056721.png" alt></p><h2 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h2><p>而已。现在你有了一个自定义的强化内核，运行一个基本的覆盖引导模糊器。所有KVM内部。</p><p>值得努力吗？即使有这个基本的模糊器，也没有输入语料库，一两天后，<a href="https://lore.kernel.org/netdev/CAJPywTJWQ9ACrp0naDn0gikU4P5-xGcGrZ6ZOKUeeC3S-k9+MA@mail.gmail.com/T/#u" target="_blank" rel="noopener">模糊</a>器发现了一个有趣的代码路径：<a href="https://lore.kernel.org/netdev/CAJPywTJWQ9ACrp0naDn0gikU4P5-xGcGrZ6ZOKUeeC3S-k9+MA@mail.gmail.com/T/#u" target="_blank" rel="noopener">NEIGH：BUG，双定时器添加，状态为8</a>。使用更专业的模糊器，一些改进“稳定性”度量和一个体面的输入语料库，我们可以期待更好的结果。</p><p>如果您想了解更多关于netlink套接字实际执行的内容，请参阅我的同事Jakub Sitnicki <a href="http://codecave.cc/multipath-routing-in-linux-part-1.html" target="_blank" rel="noopener">在Linux中的多路径路由</a>的博客文章<a href="http://codecave.cc/multipath-routing-in-linux-part-1.html" target="_blank" rel="noopener">- 第1部分</a>。然后在<a href="https://books.google.pl/books?redir_esc=y&hl=pl&id=96V4AgAAQBAJ&q=netlink#v=snippet&q=netlink&f=false" target="_blank" rel="noopener">Rami Rosen的Linux内核网络书中</a>有一篇很好的章节。</p><p>在这篇博文中我们没有提到：</p><ul><li>AFL shared_memory设置的详细信息</li><li>执行AFL持久模式</li><li>如何创建一个网络命名空间来隔离怪异的netlink命令的效果，并提高AFL得分的“稳定性”</li><li>关于如何读取dmesg（/ dev / kmsg）以查找内核崩溃的技巧</li><li>想要在KVM之外运行AFL，以获得速度和稳定性 - 目前在发现崩溃后测试不稳定</li></ul><p>但是我们实现了我们的目标 - 我们针对内核建立了一个基本但仍然有用的模糊器。最重要的是：可以重复使用相同的机制来模糊Linux子系统的其他部分 - 从文件系统到bpf验证程序。</p><p>我还学到了一个艰难的教训：调整模糊器是一项全职工作。正确的模糊测试绝对不是像启动它并无所事事地等待崩溃一样简单。总有一些东西需要改进，调整和重新实现。Mateusz Jurczyk在上述演讲开头的一句话引起了我的共鸣：</p><blockquote><p>“模糊很容易学，但很难掌握。”</p></blockquote><p>快乐虫狩猎！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
          <category> Vul </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzzing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL Fuzzing</title>
      <link href="/2018/01/22/shi-yong-afl-dui-linux-nei-he-fuzzing-de-zong-jie/"/>
      <url>/2018/01/22/shi-yong-afl-dui-linux-nei-he-fuzzing-de-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>模糊测试是一种很好的漏洞挖掘技术，Fuzzer将半随机输入喂到到测试程序，目的是找到触发错误的输入。模糊测试在查找C或C ++程序中的内存破坏漏洞时特别有用。</p><p>通常情况下，建议选择一个众所周知但很少探索的库，这个库在解析时很重要。历史上，像libjpeg，libpng和libyaml这样的东西都是完美的目标。如今找到一个好目标更难 - 一切似乎都已经被模糊化了。这是好事！我猜软件越来越好了！我没有选择用户空间目标，而是选择了Linux内核netlink机器。</p><p>Netlink是一个Linux内核工具，它用于配置网络接口，IP地址，路由表等。这是一个很好的fuzzing 目标：它是内核的一个小模块，并且生成畸形有效消息相对比较容易。最重要的是，我们可以在此过程中学到很多关于Linux内核的知识。</p><p>在这篇文章中，我将使用AFL模糊器，将netlink shim程序与自定义Linux内核相对应，所有这些都在KVM虚拟机中运行。</p><h3 id="以前的技术支持"><a href="#以前的技术支持" class="headerlink" title="以前的技术支持"></a>以前的技术支持</h3><p>我们将要使用的技术被称为“覆盖引导模糊测试”。有很多以前的文献：</p><ul><li>Dan Guido <a href="https://blog.trailofbits.com/2017/02/16/the-smart-fuzzer-revolution/" target="_blank" rel="noopener">的智能模糊革命</a>，以及<a href="https://lwn.net/Articles/677764/" target="_blank" rel="noopener">LWN</a>关于它的<a href="https://lwn.net/Articles/677764/" target="_blank" rel="noopener">文章</a></li><li>Mateusz“j00ru”Jurczyk的<a href="https://j00ru.vexillium.org/talks/blackhat-eu-effective-file-format-fuzzing-thoughts-techniques-and-results/" target="_blank" rel="noopener">有效文件格式模糊</a>测试</li><li><a href="http://honggfuzz.com/" target="_blank" rel="noopener">honggfuzz</a>是一个现代化的，功能丰富的覆盖面引导的fuzzer</li><li><a href="https://google.github.io/clusterfuzz/" target="_blank" rel="noopener">ClusterFuzz</a></li><li><a href="https://github.com/google/fuzzer-test-suite" target="_blank" rel="noopener">Fuzzer测试套件</a></li></ul><p>很多人过去都在Fuzzing Linux内核：</p><ul><li>由Dmitry Vyukov <a href="https://github.com/google/syzkaller/blob/master/docs/syzbot.md" target="_blank" rel="noopener">创建的syzkaller（又名syzbot）</a>是一个非常强大的CI风格的持续运行的内核模糊器，它已经发现了数百个漏洞。</li><li><a href="https://github.com/kernelslacker/trinity" target="_blank" rel="noopener">三位一体的模糊器</a></li></ul><p>我们将使用<a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">AFL</a>，可能是大家最喜欢的模糊器。AFL由<a href="http://lcamtuf.coredump.cx/" target="_blank" rel="noopener">MichałZalewski</a>撰写。它以其易用性，速度和非常好的变异逻辑而闻名，这是开始模糊测试之旅的完美选择！</p><p>如果您想了解有关AFL的更多信息，请参阅几个文件：</p><ul><li><a href="http://lcamtuf.coredump.cx/afl/historical_notes.txt" target="_blank" rel="noopener">历史笔记</a></li><li><a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">技术白皮书</a></li><li><a href="http://lcamtuf.coredump.cx/afl/README.txt" target="_blank" rel="noopener">自述</a></li></ul><h3 id="覆盖引导的模糊测试"><a href="#覆盖引导的模糊测试" class="headerlink" title="覆盖引导的模糊测试"></a>覆盖引导的模糊测试</h3><p>覆盖引导的模糊测试基于反馈回路的原理：</p><ul><li>模糊测试选择最有希望的测试用例</li><li>模糊测试将测试变为大量新的测试用例</li><li>目标代码运行变异的测试用例，并报告代码覆盖率</li><li>模糊器根据报告的覆盖范围计算得分，并使用它来确定有效的变异测试的优先级并删除冗余的测试</li></ul><p>例如，假设输入测试是“hello”。Fuzzer可能会将其变为多种测试，例如：“hEllo”（位翻转），“hXello”（字节插入），“hllo”（字节删除）。如果这些测试中的任何一个将产生有趣的代码覆盖，那么它将被优先化并用作下一次测试的基础。</p><p>有关如何完成突变以及如何有效地比较数千个程序运行的代码覆盖率报告的细节是模糊测试的秘诀，阅读<a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">AFL的技术白皮书</a>，可以了解更多细节。</p><p>通常，在使用AFL时，我们需要检测目标代码，以便以AFL兼容的方式报告覆盖范围。但我们想要Fuzzing 内核！我们不能只用“afl-gcc”重新编译它！。我们将准备一个二进制文件，让AFL认为它是用它的工具编译的。这个二进制文件将报告从内核中提取的代码覆盖率。</p><h3 id="内核代码覆盖率"><a href="#内核代码覆盖率" class="headerlink" title="内核代码覆盖率"></a>内核代码覆盖率</h3><p>内核至少有两个内置的覆盖机制–GCOV和KCOV：</p><ul><li><a href="https://www.kernel.org/doc/html/v4.15/dev-tools/gcov.html" target="_blank" rel="noopener">将gcov与Linux内核一起使用</a></li><li><a href="https://www.kernel.org/doc/html/latest/dev-tools/kcov.html" target="_blank" rel="noopener">KCOV：模糊测试的代码覆盖率</a></li></ul><p>KCOV的设计考虑了模糊测试，因此我们将使用它。</p><p>使用KCOV非常简单。我们必须使用正确的设置编译Linux内核。首先，启用KCOV内核配置选项：</p><pre class="line-numbers language-sh"><code class="language-sh">cd linux./scripts/config \    -e KCOV \    -d KCOV_INSTRUMENT_ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>KCOV能够记录整个内核的代码覆盖率。可以使用KCOV_INSTRUMENT_ALL选项进行设置。有个缺点是，它会减慢我们不想分析的内核部分，并且会在Fuzzing 中引入噪声（降低“稳定性”）。对于初学者，让我们禁用KCOV_INSTRUMENT_ALL并有选择地在实际想要分析的代码上启用KCOV。</p><p>我们专注于Fuzzing netlink，所以在整个“net”目录树上启用KCOV：</p><pre class="line-numbers language-sh"><code class="language-sh">find net -name Makefile | xargs -L1 -I {} bash -c 'echo "KCOV_INSTRUMENT := y" >> {}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一个理想环境中，我们只能为真正感兴趣的几个文件启用KCOV。但是netlink处理遍及网络堆栈代码，现在没有时间进行微调。</p><p>有了KCOV，将增加报告内存损坏错误的可能性。最重要的是<a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html" target="_blank" rel="noopener">KASAN</a>，使用该集合，可以编译我们的KCOV和KASAN启用的内核。</p><p>我们将以kvm运行内核，所以需要切换一下：</p><pre class="line-numbers language-sh"><code class="language-sh">./scripts/config \    -e VIRTIO -e VIRTIO_PCI -e NET_9P -e NET_9P_VIRTIO -e 9P_FS \    -e VIRTIO_NET -e VIRTIO_CONSOLE  -e DEVTMPFS ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="如何使用KCOV"><a href="#如何使用KCOV" class="headerlink" title="如何使用KCOV"></a>如何使用KCOV</h2><p>KCOV非常易于使用。首先，请注意代码覆盖率记录在每个进程的数据结构中。这意味着您必须在用户空间进程中启用和禁用KCOV，并且无法记录非任务事项的覆盖范围，例如中断处理。这对我们的需求来说完全没问题。</p><p>KCOV将数据报告给环形缓冲区。设置非常简单，<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/kcov.c" target="_blank" rel="noopener">请参阅我们的代码</a>。然后你可以使用一个简单的ioctl启用和禁用它：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">ioctl</span><span class="token punctuation">(</span>kcov_fd<span class="token punctuation">,</span> KCOV_ENABLE<span class="token punctuation">,</span> KCOV_TRACE_PC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* profiled code */</span><span class="token function">ioctl</span><span class="token punctuation">(</span>kcov_fd<span class="token punctuation">,</span> KCOV_DISABLE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在此序列之后，环形缓冲区包含启用KCOV的内核代码的所有基本块的％rip值列表。要读取缓冲区，请运行：</p><pre class="line-numbers language-c"><code class="language-c">n <span class="token operator">=</span> <span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kcov_ring<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%lx\n"</span><span class="token punctuation">,</span> kcov_ring<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用像<code>addr2line</code>这样的工具可以将％rip解析为特定的代码行。我们不需要它 - 原始的％rip值对我们来说已经足够了。</p><h2 id="将KCOV喂入AFL"><a href="#将KCOV喂入AFL" class="headerlink" title="将KCOV喂入AFL"></a>将KCOV喂入AFL</h2><p>我们旅程的下一步是学习如何欺骗AFL。请记住，AFL需要一个特制的可执行文件，但我们想要提供内核代码覆盖率。首先，我们需要了解AFL的工作原理。</p><p>AFL设置一个64K 8位数字的数组。该存储器区域称为“shared_mem”或“trace_bits”，并与跟踪的程序共享。数组中的每个字节都可以被认为是检测代码中特定（branch_src，branch_dst）对的命中计数器。</p><p>重要的是要注意AFL更喜欢随机分支标签，而不是重用％rip值来识别基本块。这是为了增加熵 - 我们希望数组中的命中计数器均匀分布。AFL使用的算法是：</p><pre class="line-numbers language-c"><code class="language-c">cur_location <span class="token operator">=</span> <span class="token operator">&lt;</span>COMPILE_TIME_RANDOM<span class="token operator">></span><span class="token punctuation">;</span>shared_mem<span class="token punctuation">[</span>cur_location <span class="token operator">^</span> prev_location<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> prev_location <span class="token operator">=</span> cur_location <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在我们使用KCOV的情况下，我们没有每个分支的编译时随机值。相反，我们将使用哈希函数从KCOV记录的％rip生成统一的16位数。这是如何将KCOV报告提供给AFL“shared_mem”数组：</p><pre class="line-numbers language-c"><code class="language-c">n <span class="token operator">=</span> <span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kcov_ring<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span><span class="token punctuation">;</span>uint16_t prev_location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        uint16_t cur_location <span class="token operator">=</span> <span class="token function">hash_function</span><span class="token punctuation">(</span>kcov_ring<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shared_mem<span class="token punctuation">[</span>cur_location <span class="token operator">^</span> prev_location<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        prev_location <span class="token operator">=</span> cur_location <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从AFL读取测试数据"><a href="#从AFL读取测试数据" class="headerlink" title="从AFL读取测试数据"></a>从AFL读取测试数据</h2><p>最后，我们需要实际编写核心netlink接口的测试代码！首先，我们需要从AFL读取输入数据。默认情况下，AFL将测试用例发送到stdin：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* read AFL test data */</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> buf_len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Fuzzing-netlink"><a href="#Fuzzing-netlink" class="headerlink" title="Fuzzing netlink"></a>Fuzzing netlink</h2><p>然后我们需要将此缓冲区发送到netlink套接字。但我们对netlink的工作原理一无所知！好吧，让我们使用前5个字节的输入作为netlink协议和组ID字段。这将允许AFL找出并猜测这些字段的正确值。代码测试netlink（简化）：</p><pre class="line-numbers language-c"><code class="language-c">netlink_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_NETLINK<span class="token punctuation">,</span> SOCK_RAW <span class="token operator">|</span> SOCK_NONBLOCK<span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> sockaddr_nl sa <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span>nl_family <span class="token operator">=</span> AF_NETLINK<span class="token punctuation">,</span>        <span class="token punctuation">.</span>nl_groups <span class="token operator">=</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span><span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">bind</span><span class="token punctuation">(</span>netlink_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> iovec iov <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf_len <span class="token operator">-</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> sockaddr_nl sax <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span>nl_family <span class="token operator">=</span> AF_NETLINK<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> msghdr msg <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">&amp;</span>sax<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sax<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>iov<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token function">sendmsg</span><span class="token punctuation">(</span>netlink_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* sendmsg succeeded! great I guess... */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本上就是这样！为了速度，我们将它包装在一个模仿<a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html" target="_blank" rel="noopener">AFL“fork服务器”逻辑</a>的短循环中。我将跳过此处的解释，<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/forksrv.c" target="_blank" rel="noopener">请参阅我们的代码了解详细信息</a>。我们的AFL-to-KCOV垫片的结果代码如下所示：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">forksrv_welcome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">forksrv_cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    test_data <span class="token operator">=</span> <span class="token function">afl_read_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kcov_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* netlink magic */</span>    <span class="token function">kcov_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* fill in shared_map with tuples recorded by kcov */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_crash_in_dmesg<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token function">forksrv_status</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token function">forksrv_status</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing/src/fuzznetlink.c" target="_blank" rel="noopener">查看完整的源代码</a>。</p><h2 id="如何运行自定义内核"><a href="#如何运行自定义内核" class="headerlink" title="如何运行自定义内核"></a>如何运行自定义内核</h2><p>我们遗漏了一个重要的部分 - 如何实际运行我们构建的自定义内核。有三种选择：</p><p><strong>“native”</strong>：您可以在服务器上完全启动构建的内核并在本机模糊它。这是最快的技术，但很有问题。如果模糊测试成功找到错误，您将崩溃机器，可能会丢失测试数据。应该避免切割我们坐的树枝。</p><p><strong>“uml”</strong>：我们可以将内核配置为以<a href="http://user-mode-linux.sourceforge.net/" target="_blank" rel="noopener">用户模式Linux运行</a>。运行UML内核不需要任何权限。内核只运行用户空间进程。UML非常酷，但遗憾的是，它不支持KASAN，因此减少了查找内存损坏错误的可能性。最后，UML是一个非常神奇的特殊环境 - 在UML中发现的错误可能与真实环境无关。有趣的是，<a href="https://source.android.com/devices/architecture/kernel/network_tests" target="_blank" rel="noopener">Android network_tests框架</a>使用UML 。</p><p><strong>“kvm”</strong>：我们可以使用kvm在虚拟化环境中运行我们的自定义内核。这就是我们要做的。</p><p>在KVM环境中运行自定义内核的最简单方法之一是使用<a href="https://github.com/amluto/virtme" target="_blank" rel="noopener">“virtme”脚本</a>。有了它们，我们可以避免创建专用的磁盘映像或分区，只需共享主机文件系统。这就是我们运行代码的方式：</p><pre class="line-numbers language-sh"><code class="language-sh">virtme-run \    --kimg bzImage \    --rw --pwd --memory 512M \    --script-sh "<what to run inside kvm>" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但坚持下去。我们忘记了为我们的模糊器准备输入语料库数据！</p><h2 id="构建输入语料库"><a href="#构建输入语料库" class="headerlink" title="构建输入语料库"></a>构建输入语料库</h2><p>每个模糊器都需要精心设计的测试用例作为输入，以引导第一个突变。测试用例应该简短，并尽可能覆盖大部分代码。可悲的是 - 我对netlink一无所知。我们怎么不准备输入语料库…</p><p>相反，我们可以要求AFL“弄清楚”哪些输入有意义。这就是<a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html" target="_blank" rel="noopener">Michał在2014年用JPEG</a>制作的，并且对他<a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html" target="_blank" rel="noopener">有用</a>。考虑到这一点，这是我们的输入语料库：</p><pre class="line-numbers language-sh"><code class="language-sh">mkdir inpecho "hello world" > inp/01.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有关如何编译和运行整个事情的说明都在我们的github上的<a href="https://github.com/cloudflare/cloudflare-blog/blob/master/2019-07-kernel-fuzzing" target="_blank" rel="noopener">README.md中</a>。归结为：</p><pre class="line-numbers language-sh"><code class="language-sh">virtme-run \    --kimg bzImage \    --rw --pwd --memory 512M \    --script-sh "./afl-fuzz -i inp -o out -- fuzznetlink" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过此运行，您将看到熟悉的AFL状态屏幕：</p><p><img src="/.top//1566885056721.png" alt></p><h2 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h2><p>而已。现在你有了一个自定义的强化内核，运行一个基本的覆盖引导模糊器。所有KVM内部。</p><p>值得努力吗？即使有这个基本的模糊器，也没有输入语料库，一两天后，<a href="https://lore.kernel.org/netdev/CAJPywTJWQ9ACrp0naDn0gikU4P5-xGcGrZ6ZOKUeeC3S-k9+MA@mail.gmail.com/T/#u" target="_blank" rel="noopener">模糊</a>器发现了一个有趣的代码路径：<a href="https://lore.kernel.org/netdev/CAJPywTJWQ9ACrp0naDn0gikU4P5-xGcGrZ6ZOKUeeC3S-k9+MA@mail.gmail.com/T/#u" target="_blank" rel="noopener">NEIGH：BUG，双定时器添加，状态为8</a>。使用更专业的模糊器，一些改进“稳定性”度量和一个体面的输入语料库，我们可以期待更好的结果。</p><p>如果您想了解更多关于netlink套接字实际执行的内容，请参阅我的同事Jakub Sitnicki <a href="http://codecave.cc/multipath-routing-in-linux-part-1.html" target="_blank" rel="noopener">在Linux中的多路径路由</a>的博客文章<a href="http://codecave.cc/multipath-routing-in-linux-part-1.html" target="_blank" rel="noopener">- 第1部分</a>。然后在<a href="https://books.google.pl/books?redir_esc=y&hl=pl&id=96V4AgAAQBAJ&q=netlink#v=snippet&q=netlink&f=false" target="_blank" rel="noopener">Rami Rosen的Linux内核网络书中</a>有一篇很好的章节。</p><p>在这篇博文中我们没有提到：</p><ul><li>AFL shared_memory设置的详细信息</li><li>执行AFL持久模式</li><li>如何创建一个网络命名空间来隔离怪异的netlink命令的效果，并提高AFL得分的“稳定性”</li><li>关于如何读取dmesg（/ dev / kmsg）以查找内核崩溃的技巧</li><li>想要在KVM之外运行AFL，以获得速度和稳定性 - 目前在发现崩溃后测试不稳定</li></ul><p>但是我们实现了我们的目标 - 我们针对内核建立了一个基本但仍然有用的模糊器。最重要的是：可以重复使用相同的机制来模糊Linux子系统的其他部分 - 从文件系统到bpf验证程序。</p><p>我还学到了一个艰难的教训：调整模糊器是一项全职工作。正确的模糊测试绝对不是像启动它并无所事事地等待崩溃一样简单。总有一些东西需要改进，调整和重新实现。Mateusz Jurczyk在上述演讲开头的一句话引起了我的共鸣：</p><blockquote><p>“模糊很容易学，但很难掌握。”</p></blockquote><p>快乐虫狩猎！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
          <category> Vul </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzzing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
